<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asio-grpc: agrpc::Waiter&lt; Signature, Executor &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">asio-grpc<span id="projectnumber">&#160;v3.6.0</span>
   </div>
   <div id="projectbrief">Asynchronous gRPC with Asio/unified executors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classagrpc_1_1_waiter.html','','classagrpc_1_1_waiter-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">agrpc::Waiter&lt; Signature, Executor &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>(experimental) Utility class for uncancelable operations  
 <a href="#details">More...</a></p>

<p><code>#include &lt;agrpc/waiter.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:rebind_5Fexecutor" id="r_rebind_5Fexecutor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structagrpc_1_1_waiter_1_1rebind__executor.html">rebind_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind the <a class="el" href="classagrpc_1_1_waiter.html" title="(experimental) Utility class for uncancelable operations">Waiter</a> to another executor.  <a href="structagrpc_1_1_waiter_1_1rebind__executor.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af957414c01d35b84cef8a6f459cacf46" id="r_af957414c01d35b84cef8a6f459cacf46"><td class="memItemLeft" align="right" valign="top"><a id="af957414c01d35b84cef8a6f459cacf46" name="af957414c01d35b84cef8a6f459cacf46"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>executor_type</b> = Executor</td></tr>
<tr class="memdesc:af957414c01d35b84cef8a6f459cacf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">The associated executor type. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afd9e6e03d3e0f9da901a976b110a58a0" id="r_afd9e6e03d3e0f9da901a976b110a58a0"><td class="memItemLeft" align="right" valign="top"><a id="afd9e6e03d3e0f9da901a976b110a58a0" name="afd9e6e03d3e0f9da901a976b110a58a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Waiter</b> () noexcept</td></tr>
<tr class="memdesc:afd9e6e03d3e0f9da901a976b110a58a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construct a <a class="el" href="classagrpc_1_1_waiter.html" title="(experimental) Utility class for uncancelable operations">Waiter</a>. <br /></td></tr>
<tr class="memitem:aa5ee9bb346765753e2a1087b3e2e3a3f" id="r_aa5ee9bb346765753e2a1087b3e2e3a3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5ee9bb346765753e2a1087b3e2e3a3f">~Waiter</a> () noexcept</td></tr>
<tr class="memdesc:aa5ee9bb346765753e2a1087b3e2e3a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the <a class="el" href="classagrpc_1_1_waiter.html" title="(experimental) Utility class for uncancelable operations">Waiter</a>.  <br /></td></tr>
<tr class="memitem:a50c80e064c5a1911d65d34e21f89df54" id="r_a50c80e064c5a1911d65d34e21f89df54"><td class="memTemplParams" colspan="2">template&lt;class Function, class ExecutorOrIoObject, class... Args&gt; </td></tr>
<tr class="memitem:a50c80e064c5a1911d65d34e21f89df54 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50c80e064c5a1911d65d34e21f89df54">initiate</a> (Function &amp;&amp;function, ExecutorOrIoObject &amp;&amp;executor_or_io_object, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a50c80e064c5a1911d65d34e21f89df54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate an operation.  <br /></td></tr>
<tr class="memitem:a1f2d63e9aaa91fe141e30cb606c41580" id="r_a1f2d63e9aaa91fe141e30cb606c41580"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f2d63e9aaa91fe141e30cb606c41580">is_ready</a> () const noexcept</td></tr>
<tr class="memdesc:a1f2d63e9aaa91fe141e30cb606c41580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the initiated operation finished?  <br /></td></tr>
<tr class="memitem:af5b5c1cd30d2d6d710b216df98c5b3ec" id="r_af5b5c1cd30d2d6d710b216df98c5b3ec"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:af5b5c1cd30d2d6d710b216df98c5b3ec template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5b5c1cd30d2d6d710b216df98c5b3ec">wait</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:af5b5c1cd30d2d6d710b216df98c5b3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the initiated operation to complete.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Signature, class Executor&gt;<br />
class agrpc::Waiter&lt; Signature, Executor &gt;</div><p>(experimental) Utility class for uncancelable operations </p>
<p>Provides cancellation support for otherwise uncancelable operations by canceling only the act of waiting for completion as opposed to the operation itself.</p>
<p>Note, this is a general purpose Asio utility and as such does not belong into asio-grpc. For coroutines, Boost.Cobalt offers a replacement in the form of <span class="tt">boost::cobalt::promise</span> with its <a href="https://www.boost.org/doc/libs/1_86_0/libs/cobalt/doc/html/index.html#interrupt_await">interrupt wait</a> feature.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Signature</td><td>Completion signature of the operation. For example, for <span class="tt"><a class="el" href="classagrpc_1_1_basic_alarm.html#a1871721d802eb738999ba0628846ed82">agrpc::Alarm::wait</a></span> this would be <span class="tt">void(bool)</span>. </td></tr>
    <tr><td class="paramname">Executor</td><td>Type of the I/O executor. For <span class="tt"><a class="el" href="namespaceagrpc.html#ad6c406cc03ead4c6f180bdf56bff6a03" title="A BasicAlarm that uses agrpc::GrpcExecutor">agrpc::Alarm</a></span> this would be <span class="tt"><a class="el" href="namespaceagrpc.html#a03ba541ef9c0352e6160442780e533b4" title="Default GrpcExecutor.">agrpc::GrpcExecutor</a></span> or <span class="tt">asio::any_io_executor</span>. Default: <span class="tt"><a class="el" href="namespaceagrpc.html#a03ba541ef9c0352e6160442780e533b4" title="Default GrpcExecutor.">agrpc::GrpcExecutor</a></span></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.7.0 (and Boost.Asio 1.77.0) </dd></dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa5ee9bb346765753e2a1087b3e2e3a3f" name="aa5ee9bb346765753e2a1087b3e2e3a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ee9bb346765753e2a1087b3e2e3a3f">&#9670;&#160;</a></span>~Waiter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature, class Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classagrpc_1_1_waiter.html">agrpc::Waiter</a>&lt; Signature, Executor &gt;::~<a class="el" href="classagrpc_1_1_waiter.html">Waiter</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destruct the <a class="el" href="classagrpc_1_1_waiter.html" title="(experimental) Utility class for uncancelable operations">Waiter</a>. </p>
<p>All initiated operations must have been <span class="tt"><a class="el" href="#af5b5c1cd30d2d6d710b216df98c5b3ec" title="Wait for the initiated operation to complete.">wait()</a></span>ed for, otherwise the behavior is undefined. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a50c80e064c5a1911d65d34e21f89df54" name="a50c80e064c5a1911d65d34e21f89df54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c80e064c5a1911d65d34e21f89df54">&#9670;&#160;</a></span>initiate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class Function, class ExecutorOrIoObject, class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_waiter.html">agrpc::Waiter</a>&lt; Signature, Executor &gt;::initiate </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutorOrIoObject &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>executor_or_io_object</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiate an operation. </p>
<p>Only one operation may be running at a time.</p>
<p>All operations must complete before this object is destructed.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>ServerRPC = <a class="code hl_class" href="classagrpc_1_1_server_r_p_c.html">agrpc::ServerRPC&lt;&amp;example::v1::Example::AsyncService::RequestBidirectionalStreaming&gt;</a>;</div>
<div class="line"> </div>
<div class="line">asio::awaitable&lt;void&gt; rpc_handler_using_waiter(ServerRPC&amp; rpc)</div>
<div class="line">{</div>
<div class="line">    ServerRPC::Request request;</div>
<div class="line">    ServerRPC::Response response;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="namespaceagrpc.html#ad6c406cc03ead4c6f180bdf56bff6a03">agrpc::Alarm</a> alarm{rpc.get_executor()};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classagrpc_1_1_waiter.html">agrpc::Waiter</a>&lt;void(<span class="keywordtype">bool</span>)&gt; waiter;</div>
<div class="line">    waiter.<a class="code hl_function" href="#a50c80e064c5a1911d65d34e21f89df54">initiate</a>(<a class="code hl_variable" href="namespaceagrpc.html#a685510388ab87c9a90c44f880e9de9cd">agrpc::read</a>, rpc, request);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> next_deadline = std::chrono::system_clock::now() + std::chrono::seconds(5);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read requests from the client and send a response back every five seconds</span></div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> [completion_order, read_error_code, read_ok, alarm_expired] =</div>
<div class="line">            <span class="keyword">co_await</span> asio::experimental::make_parallel_group(waiter.<a class="code hl_function" href="#af5b5c1cd30d2d6d710b216df98c5b3ec">wait</a>(asio::deferred),</div>
<div class="line">                                                             alarm.<a class="code hl_function" href="classagrpc_1_1_basic_alarm.html#a1871721d802eb738999ba0628846ed82">wait</a>(next_deadline, asio::deferred))</div>
<div class="line">                .async_wait(asio::experimental::wait_for_one(), asio::use_awaitable);</div>
<div class="line">        <span class="keywordflow">if</span> (0 == completion_order[0])  <span class="comment">// read completed</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (!read_ok)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">co_return</span>;</div>
<div class="line">            }</div>
<div class="line">            waiter.<a class="code hl_function" href="#a50c80e064c5a1911d65d34e21f89df54">initiate</a>(<a class="code hl_variable" href="namespaceagrpc.html#a685510388ab87c9a90c44f880e9de9cd">agrpc::read</a>, rpc, request);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span>  <span class="comment">// alarm expired</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">co_await</span> rpc.write(response, asio::use_awaitable);</div>
<div class="line">            next_deadline = std::chrono::system_clock::now() + std::chrono::seconds(5);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>When using sender/receiver and <span class="tt">function</span> returns a sender then only the <span class="tt">set_value</span> channel is forwarded to the waiting operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable that will be invoked with all subsequent arguments followed by the completion handler of this <a class="el" href="classagrpc_1_1_waiter.html" title="(experimental) Utility class for uncancelable operations">Waiter</a> (Asio) or it returns a sender composed of the result of the call (unifex/stdexec only). </td></tr>
    <tr><td class="paramname">executor_or_io_object</td><td>Either an executor itself or an object that implements <span class="tt">get_executor()</span>. This will become the I/O executor of subsequent calls to <span class="tt"><a class="el" href="#af5b5c1cd30d2d6d710b216df98c5b3ec" title="Wait for the initiated operation to complete.">wait()</a></span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f2d63e9aaa91fe141e30cb606c41580" name="a1f2d63e9aaa91fe141e30cb606c41580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2d63e9aaa91fe141e30cb606c41580">&#9670;&#160;</a></span>is_ready()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature, class Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classagrpc_1_1_waiter.html">agrpc::Waiter</a>&lt; Signature, Executor &gt;::is_ready </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the initiated operation finished? </p>
<p>Thread-safe </p>

</div>
</div>
<a id="af5b5c1cd30d2d6d710b216df98c5b3ec" name="af5b5c1cd30d2d6d710b216df98c5b3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b5c1cd30d2d6d710b216df98c5b3ec">&#9670;&#160;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_waiter.html">agrpc::Waiter</a>&lt; Signature, Executor &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for the initiated operation to complete. </p>
<p>Only one call to <span class="tt"><a class="el" href="#af5b5c1cd30d2d6d710b216df98c5b3ec" title="Wait for the initiated operation to complete.">wait()</a></span> may be outstanding at a time. May be called before an operation has been initiated. Care must be taken when invoking this function multiple times for an already completed operation as completion arguments are moved into the completion handler.</p>
<p><b>Per-Operation Cancellation</b></p>
<p>All. Upon cancellation, the initiated operation continues to run. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceagrpc.html">agrpc</a></li><li class="navelem"><a href="classagrpc_1_1_waiter.html">Waiter</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
