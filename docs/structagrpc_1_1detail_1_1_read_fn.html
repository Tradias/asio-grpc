<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="light-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asio-grpc: agrpc::detail::ReadFn Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">asio-grpc<span id="projectnumber">&#160;v1.6.0</span>
   </div>
   <div id="projectbrief">Asynchronous gRPC with Asio/unified executors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structagrpc_1_1detail_1_1_read_fn.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structagrpc_1_1detail_1_1_read_fn-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">agrpc::detail::ReadFn Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Client and server-side function object to read from streaming RPCs.  
 <a href="structagrpc_1_1detail_1_1_read_fn.html#details">More...</a></p>

<p><code>#include &lt;agrpc/rpc.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad70bfdde44d5e48c3ce0c82781521adb"><td class="memTemplParams" colspan="2">template&lt;class Response , class Request , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </td></tr>
<tr class="memitem:ad70bfdde44d5e48c3ce0c82781521adb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structagrpc_1_1detail_1_1_read_fn.html#ad70bfdde44d5e48c3ce0c82781521adb">operator()</a> (grpc::ServerAsyncReader&lt; Response, Request &gt; &amp;reader, Request &amp;<a class="el" href="namespaceagrpc.html#a4a11653afb11f9486e4e3db0136a3e08">request</a>, CompletionToken &amp;&amp;token={}) const noexcept(detail::IS_NOTRHOW_GRPC_INITIATE_COMPLETION_TOKEN&lt; CompletionToken &gt;)</td></tr>
<tr class="memdesc:ad70bfdde44d5e48c3ce0c82781521adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a client stream.  <a href="structagrpc_1_1detail_1_1_read_fn.html#ad70bfdde44d5e48c3ce0c82781521adb">More...</a><br /></td></tr>
<tr class="separator:ad70bfdde44d5e48c3ce0c82781521adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab663debda3d09bcf202cfa9e3ac52de0"><td class="memTemplParams" colspan="2">template&lt;class Response , class Request , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </td></tr>
<tr class="memitem:ab663debda3d09bcf202cfa9e3ac52de0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structagrpc_1_1detail_1_1_read_fn.html#ab663debda3d09bcf202cfa9e3ac52de0">operator()</a> (grpc::ServerAsyncReaderWriter&lt; Response, Request &gt; &amp;reader_writer, Request &amp;<a class="el" href="namespaceagrpc.html#a4a11653afb11f9486e4e3db0136a3e08">request</a>, CompletionToken &amp;&amp;token={}) const noexcept(detail::IS_NOTRHOW_GRPC_INITIATE_COMPLETION_TOKEN&lt; CompletionToken &gt;)</td></tr>
<tr class="memdesc:ab663debda3d09bcf202cfa9e3ac52de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a bidirectional stream (server-side)  <a href="structagrpc_1_1detail_1_1_read_fn.html#ab663debda3d09bcf202cfa9e3ac52de0">More...</a><br /></td></tr>
<tr class="separator:ab663debda3d09bcf202cfa9e3ac52de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3a57d2579de87909c721e31f19cf8a"><td class="memTemplParams" colspan="2">template&lt;class Response , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </td></tr>
<tr class="memitem:a5d3a57d2579de87909c721e31f19cf8a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structagrpc_1_1detail_1_1_read_fn.html#a5d3a57d2579de87909c721e31f19cf8a">operator()</a> (grpc::ClientAsyncReader&lt; Response &gt; &amp;reader, Response &amp;response, CompletionToken &amp;&amp;token={}) const noexcept(detail::IS_NOTRHOW_GRPC_INITIATE_COMPLETION_TOKEN&lt; CompletionToken &gt;)</td></tr>
<tr class="memdesc:a5d3a57d2579de87909c721e31f19cf8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a server stream.  <a href="structagrpc_1_1detail_1_1_read_fn.html#a5d3a57d2579de87909c721e31f19cf8a">More...</a><br /></td></tr>
<tr class="separator:a5d3a57d2579de87909c721e31f19cf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af737bdcfe170e27bc1c878bbe33163b8"><td class="memTemplParams" colspan="2">template&lt;class Request , class Response , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </td></tr>
<tr class="memitem:af737bdcfe170e27bc1c878bbe33163b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structagrpc_1_1detail_1_1_read_fn.html#af737bdcfe170e27bc1c878bbe33163b8">operator()</a> (grpc::ClientAsyncReaderWriter&lt; Request, Response &gt; &amp;reader_writer, Response &amp;response, CompletionToken &amp;&amp;token={}) const noexcept(detail::IS_NOTRHOW_GRPC_INITIATE_COMPLETION_TOKEN&lt; CompletionToken &gt;)</td></tr>
<tr class="memdesc:af737bdcfe170e27bc1c878bbe33163b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a bidirectional stream (client-side)  <a href="structagrpc_1_1detail_1_1_read_fn.html#af737bdcfe170e27bc1c878bbe33163b8">More...</a><br /></td></tr>
<tr class="separator:af737bdcfe170e27bc1c878bbe33163b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Client and server-side function object to read from streaming RPCs. </p>
<p >The examples below are based on the following .proto file:</p>
<div class="fragment"><div class="line">syntax = &quot;proto3&quot;;</div>
<div class="line"> </div>
<div class="line">package example.v1;</div>
<div class="line"> </div>
<div class="line">service Example {</div>
<div class="line">  rpc ServerStreaming(Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc ClientStreaming(stream Request) returns (Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc BidirectionalStreaming(stream Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc Unary(Request) returns (Response) {}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Request {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Response {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>The completion handler created from the completion token that is provided to the functions described below must have an associated executor that refers to a <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a>: <div class="fragment"><div class="line">    asio::io_context io_context;</div>
<div class="line">    asio::co_spawn(</div>
<div class="line">        io_context,</div>
<div class="line">        [&amp;]() -&gt; asio::awaitable&lt;void&gt;</div>
<div class="line">        {</div>
<div class="line">            grpc::ServerContext server_context;</div>
<div class="line">            grpc::ServerAsyncReader&lt;example::v1::Response, example::v1::Request&gt; reader{&amp;server_context};</div>
<div class="line">            <span class="comment">// error: asio::this_coro::executor does not refer to a GrpcContext</span></div>
<div class="line">            <span class="comment">// co_await agrpc::request(&amp;example::v1::Example::AsyncService::RequestClientStreaming, service,</span></div>
<div class="line">            <span class="comment">//                        server_context, reader, asio::use_awaitable);</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment">// correct:</span></div>
<div class="line">            <span class="keyword">co_await</span> <a class="code hl_variable" href="namespaceagrpc.html#a4a11653afb11f9486e4e3db0136a3e08">agrpc::request</a>(&amp;example::v1::Example::AsyncService::RequestClientStreaming, service,</div>
<div class="line">                                    server_context, reader, asio::bind_executor(grpc_context, asio::use_awaitable));</div>
<div class="line">        },</div>
<div class="line">        asio::detached);</div>
<div class="ttc" id="anamespaceagrpc_html_a4a11653afb11f9486e4e3db0136a3e08"><div class="ttname"><a href="namespaceagrpc.html#a4a11653afb11f9486e4e3db0136a3e08">agrpc::request</a></div><div class="ttdeci">constexpr detail::RequestFn request</div><div class="ttdoc">Start a new RPC.</div><div class="ttdef"><b>Definition:</b> rpc.hpp:1493</div></div>
</div><!-- fragment --></dd></dl>
<p><b>Per-Operation Cancellation</b></p>
<p >None. Operations will be cancelled when the deadline of the RPC has been reached (see <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_client_context.html#ad4e16866fee3f6ee5a10efb5be6f4da6">grpc::ClientContext::set_deadline</a>) or the call has been cancelled (see <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_client_context.html#abd0f6715c30287b75288015eee628984">grpc::ClientContext::TryCancel</a> and <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_server_context.html#a88d3a0c3d53e39f38654ce8fba968301">grpc::ServerContext::TryCancel</a>). </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a5d3a57d2579de87909c721e31f19cf8a" name="a5d3a57d2579de87909c721e31f19cf8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3a57d2579de87909c721e31f19cf8a">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Response , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::ReadFn::operator() </td>
          <td>(</td>
          <td class="paramtype">grpc::ClientAsyncReader&lt; Response &gt; &amp;&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Response &amp;&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from a server stream. </p>
<p >It should not be called concurrently with other streaming APIs on the same stream. It is not meaningful to call it concurrently with another read on the same stream since reads on the same stream are delivered in order.</p>
<p >Example:</p>
<div class="fragment"><div class="line">    example::v1::Response response;</div>
<div class="line">    <span class="keywordtype">bool</span> read_ok = <span class="keyword">co_await</span> <a class="code hl_variable" href="namespaceagrpc.html#a685510388ab87c9a90c44f880e9de9cd">agrpc::read</a>(*reader, response, asio::use_awaitable);</div>
<div class="ttc" id="anamespaceagrpc_html_a685510388ab87c9a90c44f880e9de9cd"><div class="ttname"><a href="namespaceagrpc.html#a685510388ab87c9a90c44f880e9de9cd">agrpc::read</a></div><div class="ttdeci">constexpr detail::ReadFn read</div><div class="ttdoc">Read from a streaming RPC.</div><div class="ttdef"><b>Definition:</b> rpc.hpp:1502</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or the one created by <code><a class="el" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9" title="Create sender completion token.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. <code>true</code> indicates that a valid message was read, <code>false</code> when the call is dead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af737bdcfe170e27bc1c878bbe33163b8" name="af737bdcfe170e27bc1c878bbe33163b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af737bdcfe170e27bc1c878bbe33163b8">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request , class Response , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::ReadFn::operator() </td>
          <td>(</td>
          <td class="paramtype">grpc::ClientAsyncReaderWriter&lt; Request, Response &gt; &amp;&#160;</td>
          <td class="paramname"><em>reader_writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Response &amp;&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from a bidirectional stream (client-side) </p>
<p >This is thread-safe with respect to write or writes_done methods. It should not be called concurrently with other streaming APIs on the same stream. It is not meaningful to call it concurrently with another read on the same stream since reads on the same stream are delivered in order.</p>
<p >Example:</p>
<div class="fragment"><div class="line">    example::v1::Response response;</div>
<div class="line">    <span class="keywordtype">bool</span> read_ok = <span class="keyword">co_await</span> <a class="code hl_variable" href="namespaceagrpc.html#a685510388ab87c9a90c44f880e9de9cd">agrpc::read</a>(*reader_writer, response, asio::use_awaitable);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or the one created by <code><a class="el" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9" title="Create sender completion token.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. <code>true</code> indicates that a valid message was read, <code>false</code> when the call is dead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad70bfdde44d5e48c3ce0c82781521adb" name="ad70bfdde44d5e48c3ce0c82781521adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70bfdde44d5e48c3ce0c82781521adb">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Response , class Request , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::ReadFn::operator() </td>
          <td>(</td>
          <td class="paramtype">grpc::ServerAsyncReader&lt; Response, Request &gt; &amp;&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Request &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from a client stream. </p>
<p >It should not be called concurrently with other streaming APIs on the same stream. It is not meaningful to call it concurrently with another read on the same stream since reads on the same stream are delivered in order.</p>
<p >Example:</p>
<div class="fragment"><div class="line">    example::v1::Request <a class="code hl_variable" href="namespaceagrpc.html#a4a11653afb11f9486e4e3db0136a3e08">request</a>;</div>
<div class="line">    <span class="keywordtype">bool</span> read_ok = <span class="keyword">co_await</span> <a class="code hl_variable" href="namespaceagrpc.html#a685510388ab87c9a90c44f880e9de9cd">agrpc::read</a>(reader, <a class="code hl_variable" href="namespaceagrpc.html#a4a11653afb11f9486e4e3db0136a3e08">request</a>, asio::use_awaitable);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or the one created by <code><a class="el" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9" title="Create sender completion token.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. <code>true</code> indicates that a valid message was read. If not, you know that there are certainly no more messages that can ever be read from this stream. This could happen because the client has done a WritesDone already. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab663debda3d09bcf202cfa9e3ac52de0" name="ab663debda3d09bcf202cfa9e3ac52de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab663debda3d09bcf202cfa9e3ac52de0">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Response , class Request , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::ReadFn::operator() </td>
          <td>(</td>
          <td class="paramtype">grpc::ServerAsyncReaderWriter&lt; Response, Request &gt; &amp;&#160;</td>
          <td class="paramname"><em>reader_writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Request &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from a bidirectional stream (server-side) </p>
<p >This is thread-safe with respect to write or writes_done methods on the same stream. It should not be called concurrently with another read on the same stream as the order of delivery will not be defined.</p>
<p >Example:</p>
<div class="fragment"><div class="line">    example::v1::Request <a class="code hl_variable" href="namespaceagrpc.html#a4a11653afb11f9486e4e3db0136a3e08">request</a>;</div>
<div class="line">    <span class="keywordtype">bool</span> read_ok = <span class="keyword">co_await</span> <a class="code hl_variable" href="namespaceagrpc.html#a685510388ab87c9a90c44f880e9de9cd">agrpc::read</a>(reader_writer, <a class="code hl_variable" href="namespaceagrpc.html#a4a11653afb11f9486e4e3db0136a3e08">request</a>, asio::use_awaitable);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or the one created by <code><a class="el" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9" title="Create sender completion token.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. <code>true</code> indicates that a valid message was read. <code>false</code> when there will be no more incoming messages, either because the other side has called WritesDone() or the stream has failed (or been cancelled). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceagrpc.html">agrpc</a></li><li class="navelem"><b>detail</b></li><li class="navelem"><a class="el" href="structagrpc_1_1detail_1_1_read_fn.html">ReadFn</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
