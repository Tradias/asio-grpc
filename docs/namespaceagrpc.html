<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asio-grpc: agrpc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">asio-grpc<span id="projectnumber">&#160;v3.6.0</span>
   </div>
   <div id="projectbrief">Asynchronous gRPC with Asio/unified executors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespaceagrpc.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">agrpc Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Public namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:BasicAlarm" id="r_BasicAlarm"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_basic_alarm.html">BasicAlarm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O object for <span class="tt">grpc::Alarm</span>  <a href="classagrpc_1_1_basic_alarm.html#details">More...</a><br /></td></tr>
<tr class="memitem:BasicClientBidiReactor" id="r_BasicClientBidiReactor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">BasicClientBidiReactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for client-side, bidi-streaming rpcs  <a href="classagrpc_1_1_basic_client_bidi_reactor.html#details">More...</a><br /></td></tr>
<tr class="memitem:BasicClientReadReactor" id="r_BasicClientReadReactor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_basic_client_read_reactor.html">BasicClientReadReactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for client-side, server-streaming rpcs  <a href="classagrpc_1_1_basic_client_read_reactor.html#details">More...</a><br /></td></tr>
<tr class="memitem:BasicClientUnaryReactor" id="r_BasicClientUnaryReactor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_basic_client_unary_reactor.html">BasicClientUnaryReactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for client-side, unary rpcs  <a href="classagrpc_1_1_basic_client_unary_reactor.html#details">More...</a><br /></td></tr>
<tr class="memitem:BasicClientWriteReactor" id="r_BasicClientWriteReactor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_basic_client_write_reactor.html">BasicClientWriteReactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for client-side, client-streaming rpcs  <a href="classagrpc_1_1_basic_client_write_reactor.html#details">More...</a><br /></td></tr>
<tr class="memitem:BasicGrpcExecutor" id="r_BasicGrpcExecutor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_basic_grpc_executor.html">BasicGrpcExecutor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a>'s executor.  <a href="classagrpc_1_1_basic_grpc_executor.html#details">More...</a><br /></td></tr>
<tr class="memitem:BasicServerBidiReactor" id="r_BasicServerBidiReactor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_basic_server_bidi_reactor.html">BasicServerBidiReactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for server-side, bidi-streaming rpcs  <a href="classagrpc_1_1_basic_server_bidi_reactor.html#details">More...</a><br /></td></tr>
<tr class="memitem:BasicServerReadReactor" id="r_BasicServerReadReactor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_basic_server_read_reactor.html">BasicServerReadReactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for server-side, client-streaming rpcs  <a href="classagrpc_1_1_basic_server_read_reactor.html#details">More...</a><br /></td></tr>
<tr class="memitem:BasicServerUnaryReactor" id="r_BasicServerUnaryReactor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_basic_server_unary_reactor.html">BasicServerUnaryReactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for server-side, unary rpcs  <a href="classagrpc_1_1_basic_server_unary_reactor.html#details">More...</a><br /></td></tr>
<tr class="memitem:BasicServerWriteReactor" id="r_BasicServerWriteReactor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_basic_server_write_reactor.html">BasicServerWriteReactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for server-side, server-streaming rpcs  <a href="classagrpc_1_1_basic_server_write_reactor.html#details">More...</a><br /></td></tr>
<tr class="memitem:ClientRPC" id="r_ClientRPC"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_client_r_p_c.html">ClientRPC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary <a class="el" href="classagrpc_1_1_client_r_p_c.html" title="Primary ClientRPC template.">ClientRPC</a> template.  <a href="classagrpc_1_1_client_r_p_c.html#details">More...</a><br /></td></tr>
<tr class="memitem:ClientRPC_3C_20agrpc_3A_3AClientRPCType_3A_3AGENERIC_5FUNARY_2C_20Executor_20_3E" id="r_ClientRPC_3C_20agrpc_3A_3AClientRPCType_3A_3AGENERIC_5FUNARY_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_client_r_p_c_3_01agrpc_1_1_client_r_p_c_type_1_1_g_e_n_e_r_i_c___u_n_a_r_y_00_01_executor_01_4.html">ClientRPC&lt; agrpc::ClientRPCType::GENERIC_UNARY, Executor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O object for client-side, generic, unary rpcs.  <a href="classagrpc_1_1_client_r_p_c_3_01agrpc_1_1_client_r_p_c_type_1_1_g_e_n_e_r_i_c___u_n_a_r_y_00_01_executor_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:ClientRPC_3C_20PrepareAsyncBidiStreaming_2C_20Executor_20_3E" id="r_ClientRPC_3C_20PrepareAsyncBidiStreaming_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4.html">ClientRPC&lt; PrepareAsyncBidiStreaming, Executor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O object for client-side, bidirectional-streaming rpcs.  <a href="classagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:ClientRPC_3C_20PrepareAsyncClientStreaming_2C_20Executor_20_3E" id="r_ClientRPC_3C_20PrepareAsyncClientStreaming_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_client_r_p_c_3_01_prepare_async_client_streaming_00_01_executor_01_4.html">ClientRPC&lt; PrepareAsyncClientStreaming, Executor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O object for client-side, client-streaming rpcs.  <a href="classagrpc_1_1_client_r_p_c_3_01_prepare_async_client_streaming_00_01_executor_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:ClientRPC_3C_20PrepareAsyncServerStreaming_2C_20Executor_20_3E" id="r_ClientRPC_3C_20PrepareAsyncServerStreaming_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_client_r_p_c_3_01_prepare_async_server_streaming_00_01_executor_01_4.html">ClientRPC&lt; PrepareAsyncServerStreaming, Executor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O object for client-side, server-streaming rpcs.  <a href="classagrpc_1_1_client_r_p_c_3_01_prepare_async_server_streaming_00_01_executor_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:ClientRPC_3C_20PrepareAsyncUnary_2C_20Executor_20_3E" id="r_ClientRPC_3C_20PrepareAsyncUnary_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_client_r_p_c_3_01_prepare_async_unary_00_01_executor_01_4.html">ClientRPC&lt; PrepareAsyncUnary, Executor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O object for client-side, unary rpcs.  <a href="classagrpc_1_1_client_r_p_c_3_01_prepare_async_unary_00_01_executor_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:DefaultRunTraits" id="r_DefaultRunTraits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structagrpc_1_1_default_run_traits.html">DefaultRunTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) Default run traits  <a href="structagrpc_1_1_default_run_traits.html#details">More...</a><br /></td></tr>
<tr class="memitem:DefaultServerRPCTraits" id="r_DefaultServerRPCTraits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structagrpc_1_1_default_server_r_p_c_traits.html">DefaultServerRPCTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a> traits.  <a href="structagrpc_1_1_default_server_r_p_c_traits.html#details">More...</a><br /></td></tr>
<tr class="memitem:GrpcContext" id="r_GrpcContext"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_grpc_context.html">GrpcContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution context based on <span class="tt">grpc::CompletionQueue</span>  <a href="classagrpc_1_1_grpc_context.html#details">More...</a><br /></td></tr>
<tr class="memitem:HealthCheckService" id="r_HealthCheckService"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_health_check_service.html">HealthCheckService</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CompletionQueue-based implementation of grpc::HealthCheckServiceInterface.  <a href="classagrpc_1_1_health_check_service.html#details">More...</a><br /></td></tr>
<tr class="memitem:ReactorPtr" id="r_ReactorPtr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_reactor_ptr.html">ReactorPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer-like object for reactors.  <a href="classagrpc_1_1_reactor_ptr.html#details">More...</a><br /></td></tr>
<tr class="memitem:ServerRPC" id="r_ServerRPC"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary <a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a> template.  <a href="classagrpc_1_1_server_r_p_c.html#details">More...</a><br /></td></tr>
<tr class="memitem:ServerRPC_3C_20agrpc_3A_3AServerRPCType_3A_3AGENERIC_2C_20TraitsT_2C_20Executor_20_3E" id="r_ServerRPC_3C_20agrpc_3A_3AServerRPCType_3A_3AGENERIC_2C_20TraitsT_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_server_r_p_c_3_01agrpc_1_1_server_r_p_c_type_1_1_g_e_n_e_r_i_c_00_01_traits_t_00_01_executor_01_4.html">ServerRPC&lt; agrpc::ServerRPCType::GENERIC, TraitsT, Executor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O object for server-side, generic rpcs.  <a href="classagrpc_1_1_server_r_p_c_3_01agrpc_1_1_server_r_p_c_type_1_1_g_e_n_e_r_i_c_00_01_traits_t_00_01_executor_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:ServerRPC_3C_20RequestBidiStreaming_2C_20TraitsT_2C_20Executor_20_3E" id="r_ServerRPC_3C_20RequestBidiStreaming_2C_20TraitsT_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_server_r_p_c_3_01_request_bidi_streaming_00_01_traits_t_00_01_executor_01_4.html">ServerRPC&lt; RequestBidiStreaming, TraitsT, Executor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O object for server-side, bidirectional-streaming rpcs.  <a href="classagrpc_1_1_server_r_p_c_3_01_request_bidi_streaming_00_01_traits_t_00_01_executor_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:ServerRPC_3C_20RequestClientStreaming_2C_20TraitsT_2C_20Executor_20_3E" id="r_ServerRPC_3C_20RequestClientStreaming_2C_20TraitsT_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_server_r_p_c_3_01_request_client_streaming_00_01_traits_t_00_01_executor_01_4.html">ServerRPC&lt; RequestClientStreaming, TraitsT, Executor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O object for server-side, client-streaming rpcs.  <a href="classagrpc_1_1_server_r_p_c_3_01_request_client_streaming_00_01_traits_t_00_01_executor_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:ServerRPC_3C_20RequestServerStreaming_2C_20TraitsT_2C_20Executor_20_3E" id="r_ServerRPC_3C_20RequestServerStreaming_2C_20TraitsT_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_server_r_p_c_3_01_request_server_streaming_00_01_traits_t_00_01_executor_01_4.html">ServerRPC&lt; RequestServerStreaming, TraitsT, Executor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O object for server-side, server-streaming rpcs.  <a href="classagrpc_1_1_server_r_p_c_3_01_request_server_streaming_00_01_traits_t_00_01_executor_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:ServerRPC_3C_20RequestUnary_2C_20TraitsT_2C_20Executor_20_3E" id="r_ServerRPC_3C_20RequestUnary_2C_20TraitsT_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_server_r_p_c_3_01_request_unary_00_01_traits_t_00_01_executor_01_4.html">ServerRPC&lt; RequestUnary, TraitsT, Executor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O object for server-side, unary rpcs.  <a href="classagrpc_1_1_server_r_p_c_3_01_request_unary_00_01_traits_t_00_01_executor_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:ServerRPCPtr" id="r_ServerRPCPtr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_server_r_p_c_ptr.html">ServerRPCPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocated <a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a> created by register_callback_rpc_handler.  <a href="classagrpc_1_1_server_r_p_c_ptr.html#details">More...</a><br /></td></tr>
<tr class="memitem:UseSender" id="r_UseSender"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structagrpc_1_1_use_sender.html">UseSender</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sender completion token.  <a href="structagrpc_1_1_use_sender.html#details">More...</a><br /></td></tr>
<tr class="memitem:Waiter" id="r_Waiter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_waiter.html">Waiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) Utility class for uncancelable operations  <a href="classagrpc_1_1_waiter.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad6c406cc03ead4c6f180bdf56bff6a03" id="r_ad6c406cc03ead4c6f180bdf56bff6a03"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6c406cc03ead4c6f180bdf56bff6a03">Alarm</a> = <a class="el" href="classagrpc_1_1_basic_alarm.html">agrpc::BasicAlarm</a>&lt;<a class="el" href="#a03ba541ef9c0352e6160442780e533b4">agrpc::GrpcExecutor</a>&gt;</td></tr>
<tr class="memdesc:ad6c406cc03ead4c6f180bdf56bff6a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classagrpc_1_1_basic_alarm.html" title="I/O object for grpc::Alarm">BasicAlarm</a> that uses <span class="tt"><a class="el" href="#a03ba541ef9c0352e6160442780e533b4" title="Default GrpcExecutor.">agrpc::GrpcExecutor</a></span>  <br /></td></tr>
<tr class="memitem:a40bf242fb8bf95903420b1c2188a4a62" id="r_a40bf242fb8bf95903420b1c2188a4a62"><td class="memItemLeft" align="right" valign="top"><a id="a40bf242fb8bf95903420b1c2188a4a62" name="a40bf242fb8bf95903420b1c2188a4a62"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ClientUnaryReactor</b> = <a class="el" href="classagrpc_1_1_basic_client_unary_reactor.html">BasicClientUnaryReactor</a>&lt;detail::DefaultReactorExecutor&gt;</td></tr>
<tr class="memdesc:a40bf242fb8bf95903420b1c2188a4a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for client-side, unary rpcs (specialized on <span class="tt">asio::any_io_executor</span>) <br /></td></tr>
<tr class="memitem:a51bb39f4635510eb0fc12a026d656ab3" id="r_a51bb39f4635510eb0fc12a026d656ab3"><td class="memTemplParams" colspan="2"><a id="a51bb39f4635510eb0fc12a026d656ab3" name="a51bb39f4635510eb0fc12a026d656ab3"></a>
template&lt;class Request&gt; </td></tr>
<tr class="memitem:a51bb39f4635510eb0fc12a026d656ab3 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>ClientWriteReactor</b> = <a class="el" href="classagrpc_1_1_basic_client_write_reactor.html">BasicClientWriteReactor</a>&lt;Request, detail::DefaultReactorExecutor&gt;</td></tr>
<tr class="memdesc:a51bb39f4635510eb0fc12a026d656ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for client-side, client-streaming rpcs (specialized on <span class="tt">asio::any_io_executor</span>) <br /></td></tr>
<tr class="memitem:a28dab8f49d9237cd4271ca0dc9fb96df" id="r_a28dab8f49d9237cd4271ca0dc9fb96df"><td class="memTemplParams" colspan="2"><a id="a28dab8f49d9237cd4271ca0dc9fb96df" name="a28dab8f49d9237cd4271ca0dc9fb96df"></a>
template&lt;class Response&gt; </td></tr>
<tr class="memitem:a28dab8f49d9237cd4271ca0dc9fb96df template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>ClientReadReactor</b> = <a class="el" href="classagrpc_1_1_basic_client_read_reactor.html">BasicClientReadReactor</a>&lt;Response, detail::DefaultReactorExecutor&gt;</td></tr>
<tr class="memdesc:a28dab8f49d9237cd4271ca0dc9fb96df"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for client-side, server-streaming rpcs (specialized on <span class="tt">asio::any_io_executor</span>) <br /></td></tr>
<tr class="memitem:a586bf412aaf87ea30e1991d7b3bcef6b" id="r_a586bf412aaf87ea30e1991d7b3bcef6b"><td class="memTemplParams" colspan="2"><a id="a586bf412aaf87ea30e1991d7b3bcef6b" name="a586bf412aaf87ea30e1991d7b3bcef6b"></a>
template&lt;class Request, class Response&gt; </td></tr>
<tr class="memitem:a586bf412aaf87ea30e1991d7b3bcef6b template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>ClientBidiReactor</b> = <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">BasicClientBidiReactor</a>&lt;Request, Response, detail::DefaultReactorExecutor&gt;</td></tr>
<tr class="memdesc:a586bf412aaf87ea30e1991d7b3bcef6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for client-side, bidi-streaming rpcs (specialized on <span class="tt">asio::any_io_executor</span>) <br /></td></tr>
<tr class="memitem:a25a436b55412d2716c905ce0522bd84c" id="r_a25a436b55412d2716c905ce0522bd84c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25a436b55412d2716c905ce0522bd84c">GenericUnaryClientRPC</a> = <a class="el" href="classagrpc_1_1_client_r_p_c.html">agrpc::ClientRPC</a>&lt;<a class="el" href="#a42c57be5049212df6909b6da0c60d36ea2a1be6738d2573a3eecd21f772e11756">agrpc::ClientRPCType::GENERIC_UNARY</a>&gt;</td></tr>
<tr class="memdesc:a25a436b55412d2716c905ce0522bd84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O object for client-side, generic, unary rpcs (type alias)  <br /></td></tr>
<tr class="memitem:a644b312cfc6e64a0e50ab525cb095077" id="r_a644b312cfc6e64a0e50ab525cb095077"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a644b312cfc6e64a0e50ab525cb095077">GenericStreamingClientRPC</a> = <a class="el" href="classagrpc_1_1_client_r_p_c.html">agrpc::ClientRPC</a>&lt;<a class="el" href="#a42c57be5049212df6909b6da0c60d36eadf49273525fcac45f0fe3afd8c7a5454">agrpc::ClientRPCType::GENERIC_STREAMING</a>&gt;</td></tr>
<tr class="memdesc:a644b312cfc6e64a0e50ab525cb095077"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O object for client-side, generic, streaming rpcs (type alias)  <br /></td></tr>
<tr class="memitem:a03ba541ef9c0352e6160442780e533b4" id="r_a03ba541ef9c0352e6160442780e533b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03ba541ef9c0352e6160442780e533b4">GrpcExecutor</a> = <a class="el" href="classagrpc_1_1_basic_grpc_executor.html">agrpc::BasicGrpcExecutor</a>&lt;&gt;</td></tr>
<tr class="memdesc:a03ba541ef9c0352e6160442780e533b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <a class="el" href="#a03ba541ef9c0352e6160442780e533b4" title="Default GrpcExecutor.">GrpcExecutor</a>.  <br /></td></tr>
<tr class="memitem:a41df67b4a7412df071a87b872347cf86" id="r_a41df67b4a7412df071a87b872347cf86"><td class="memItemLeft" align="right" valign="top"><a id="a41df67b4a7412df071a87b872347cf86" name="a41df67b4a7412df071a87b872347cf86"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ServerUnaryReactor</b> = <a class="el" href="classagrpc_1_1_basic_server_unary_reactor.html">BasicServerUnaryReactor</a>&lt;detail::DefaultReactorExecutor&gt;</td></tr>
<tr class="memdesc:a41df67b4a7412df071a87b872347cf86"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for server-side, unary rpcs (specialized on <span class="tt">asio::any_io_executor</span>) <br /></td></tr>
<tr class="memitem:ac2c73e8e6544d2180a6b611af74bebce" id="r_ac2c73e8e6544d2180a6b611af74bebce"><td class="memTemplParams" colspan="2"><a id="ac2c73e8e6544d2180a6b611af74bebce" name="ac2c73e8e6544d2180a6b611af74bebce"></a>
template&lt;class Request&gt; </td></tr>
<tr class="memitem:ac2c73e8e6544d2180a6b611af74bebce template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>ServerReadReactor</b> = <a class="el" href="classagrpc_1_1_basic_server_read_reactor.html">BasicServerReadReactor</a>&lt;Request, detail::DefaultReactorExecutor&gt;</td></tr>
<tr class="memdesc:ac2c73e8e6544d2180a6b611af74bebce"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for server-side, client-streaming rpcs (specialized on <span class="tt">asio::any_io_executor</span>) <br /></td></tr>
<tr class="memitem:acb4b26ee6be4b141aadd2a836ba406b5" id="r_acb4b26ee6be4b141aadd2a836ba406b5"><td class="memTemplParams" colspan="2"><a id="acb4b26ee6be4b141aadd2a836ba406b5" name="acb4b26ee6be4b141aadd2a836ba406b5"></a>
template&lt;class Response&gt; </td></tr>
<tr class="memitem:acb4b26ee6be4b141aadd2a836ba406b5 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>ServerWriteReactor</b> = <a class="el" href="classagrpc_1_1_basic_server_write_reactor.html">BasicServerWriteReactor</a>&lt;Response, detail::DefaultReactorExecutor&gt;</td></tr>
<tr class="memdesc:acb4b26ee6be4b141aadd2a836ba406b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for server-side, server-streaming rpcs (specialized on <span class="tt">asio::any_io_executor</span>) <br /></td></tr>
<tr class="memitem:a7976c0a4fb00aa683bda0636a93ca35a" id="r_a7976c0a4fb00aa683bda0636a93ca35a"><td class="memTemplParams" colspan="2"><a id="a7976c0a4fb00aa683bda0636a93ca35a" name="a7976c0a4fb00aa683bda0636a93ca35a"></a>
template&lt;class Request, class Response&gt; </td></tr>
<tr class="memitem:a7976c0a4fb00aa683bda0636a93ca35a template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>ServerBidiReactor</b> = <a class="el" href="classagrpc_1_1_basic_server_bidi_reactor.html">BasicServerBidiReactor</a>&lt;Request, Response, detail::DefaultReactorExecutor&gt;</td></tr>
<tr class="memdesc:a7976c0a4fb00aa683bda0636a93ca35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) I/O object for server-side, bidi-streaming rpcs (specialized on <span class="tt">asio::any_io_executor</span>) <br /></td></tr>
<tr class="memitem:a7d5eebaa6f815abd3ae12325f88fd253" id="r_a7d5eebaa6f815abd3ae12325f88fd253"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d5eebaa6f815abd3ae12325f88fd253">GenericServerRPC</a> = <a class="el" href="classagrpc_1_1_server_r_p_c.html">agrpc::ServerRPC</a>&lt;<a class="el" href="#a819aed2748e29d498c18adfcc5855216ac942dc2a9f958acddc67e11472d3ca0b">agrpc::ServerRPCType::GENERIC</a>&gt;</td></tr>
<tr class="memdesc:a7d5eebaa6f815abd3ae12325f88fd253"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O object for server-side, generic rpcs (type alias)  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a42c57be5049212df6909b6da0c60d36e" id="r_a42c57be5049212df6909b6da0c60d36e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c57be5049212df6909b6da0c60d36e">ClientRPCType</a> { <br />
&#160;&#160;<a class="el" href="#a42c57be5049212df6909b6da0c60d36ea8ca44f46ef1f04b2113678603c3800b4">UNARY</a>
, <a class="el" href="#a42c57be5049212df6909b6da0c60d36ea2a1be6738d2573a3eecd21f772e11756">GENERIC_UNARY</a>
, <a class="el" href="#a42c57be5049212df6909b6da0c60d36eaeb1bcff53747fbcc6c2ded49b5724257">SERVER_STREAMING</a>
, <a class="el" href="#a42c57be5049212df6909b6da0c60d36ea1350d72153c5dd5e5cbaffc22da1cfdc">CLIENT_STREAMING</a>
, <br />
&#160;&#160;<a class="el" href="#a42c57be5049212df6909b6da0c60d36eaf92e0d805b776fa75c63d16707f99111">BIDIRECTIONAL_STREAMING</a>
, <a class="el" href="#a42c57be5049212df6909b6da0c60d36eadf49273525fcac45f0fe3afd8c7a5454">GENERIC_STREAMING</a>
<br />
 }</td></tr>
<tr class="memdesc:a42c57be5049212df6909b6da0c60d36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a ClientRPC.  <a href="#a42c57be5049212df6909b6da0c60d36e">More...</a><br /></td></tr>
<tr class="memitem:a819aed2748e29d498c18adfcc5855216" id="r_a819aed2748e29d498c18adfcc5855216"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a819aed2748e29d498c18adfcc5855216">ServerRPCType</a> { <br />
&#160;&#160;<a class="el" href="#a819aed2748e29d498c18adfcc5855216a8ca44f46ef1f04b2113678603c3800b4">UNARY</a>
, <a class="el" href="#a819aed2748e29d498c18adfcc5855216aeb1bcff53747fbcc6c2ded49b5724257">SERVER_STREAMING</a>
, <a class="el" href="#a819aed2748e29d498c18adfcc5855216a1350d72153c5dd5e5cbaffc22da1cfdc">CLIENT_STREAMING</a>
, <a class="el" href="#a819aed2748e29d498c18adfcc5855216af92e0d805b776fa75c63d16707f99111">BIDIRECTIONAL_STREAMING</a>
, <br />
&#160;&#160;<a class="el" href="#a819aed2748e29d498c18adfcc5855216ac942dc2a9f958acddc67e11472d3ca0b">GENERIC</a>
<br />
 }</td></tr>
<tr class="memdesc:a819aed2748e29d498c18adfcc5855216"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a ServerRPC.  <a href="#a819aed2748e29d498c18adfcc5855216">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a91f47317f73d2a74002922459fd283fb" id="r_a91f47317f73d2a74002922459fd283fb"><td class="memTemplParams" colspan="2">template&lt;class StubAsync, class Request, class Response, class CompletionToken = detail::DefaultCompletionTokenT&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a91f47317f73d2a74002922459fd283fb template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91f47317f73d2a74002922459fd283fb">unary_call</a> (detail::AsyncUnaryFn&lt; StubAsync, Request, Response &gt; fn, StubAsync *stub, grpc::ClientContext &amp;client_context, const Request &amp;req, Response &amp;response, CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a91f47317f73d2a74002922459fd283fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) Perform a unary rpc  <br /></td></tr>
<tr class="memitem:a0704072818e6d125ef22b0ae1bbe324e" id="r_a0704072818e6d125ef22b0ae1bbe324e"><td class="memTemplParams" colspan="2">template&lt;class Reactor, class Allocator, class... Args, class = std::enable_if_t&lt;!std::is_same_v&lt;void, detail::ReactorExecutorTypeT&lt;Reactor&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a0704072818e6d125ef22b0ae1bbe324e template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0704072818e6d125ef22b0ae1bbe324e">allocate_reactor</a> (Allocator allocator, detail::ReactorExecutorTypeT&lt; Reactor &gt; executor, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0704072818e6d125ef22b0ae1bbe324e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classagrpc_1_1_reactor_ptr.html" title="Shared pointer-like object for reactors.">ReactorPtr</a> using allocator.  <br /></td></tr>
<tr class="memitem:a737b02be94cff8e511123b630f1fff79" id="r_a737b02be94cff8e511123b630f1fff79"><td class="memTemplParams" colspan="2">template&lt;class Reactor, class Allocator, class... Args, class = std::enable_if_t&lt;std::is_same_v&lt;void, detail::ReactorExecutorTypeT&lt;Reactor&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a737b02be94cff8e511123b630f1fff79 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classagrpc_1_1_reactor_ptr.html">ReactorPtr</a>&lt; Reactor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a737b02be94cff8e511123b630f1fff79">allocate_reactor</a> (Allocator allocator, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a737b02be94cff8e511123b630f1fff79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classagrpc_1_1_reactor_ptr.html" title="Shared pointer-like object for reactors.">ReactorPtr</a> using allocator (sender/receiver overload)  <br /></td></tr>
<tr class="memitem:a59ca62564b50007b111375aa090e752b" id="r_a59ca62564b50007b111375aa090e752b"><td class="memTemplParams" colspan="2">template&lt;class Reactor, class... Args, class = std::enable_if_t&lt;!std::is_same_v&lt;void, detail::ReactorExecutorTypeT&lt;Reactor&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a59ca62564b50007b111375aa090e752b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classagrpc_1_1_reactor_ptr.html">ReactorPtr</a>&lt; Reactor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59ca62564b50007b111375aa090e752b">make_reactor</a> (detail::ReactorExecutorTypeT&lt; Reactor &gt; executor, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a59ca62564b50007b111375aa090e752b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classagrpc_1_1_reactor_ptr.html" title="Shared pointer-like object for reactors.">ReactorPtr</a>.  <br /></td></tr>
<tr class="memitem:a76ba647b5fba8b9ddeb615be745cabbb" id="r_a76ba647b5fba8b9ddeb615be745cabbb"><td class="memTemplParams" colspan="2">template&lt;class Reactor, class... Args, class = std::enable_if_t&lt;std::is_same_v&lt;void, detail::ReactorExecutorTypeT&lt;Reactor&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a76ba647b5fba8b9ddeb615be745cabbb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classagrpc_1_1_reactor_ptr.html">ReactorPtr</a>&lt; Reactor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76ba647b5fba8b9ddeb615be745cabbb">make_reactor</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a76ba647b5fba8b9ddeb615be745cabbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classagrpc_1_1_reactor_ptr.html" title="Shared pointer-like object for reactors.">ReactorPtr</a> (sender/receiver overload)  <br /></td></tr>
<tr class="memitem:ae09f3bd4a00ce92682d30395d1fba52f" id="r_ae09f3bd4a00ce92682d30395d1fba52f"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class RPCHandler, class CompletionToken = detail::DefaultCompletionTokenT&lt;typename ServerRPC::executor_type&gt;&gt; </td></tr>
<tr class="memitem:ae09f3bd4a00ce92682d30395d1fba52f template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae09f3bd4a00ce92682d30395d1fba52f">register_awaitable_rpc_handler</a> (const typename ServerRPC::executor_type &amp;executor, detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;service, RPCHandler rpc_handler, CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:ae09f3bd4a00ce92682d30395d1fba52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an awaitable rpc handler for the given method.  <br /></td></tr>
<tr class="memitem:a015eb1af78b29c2018f3635eb278ed0b" id="r_a015eb1af78b29c2018f3635eb278ed0b"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class RPCHandler, class CompletionToken&gt; </td></tr>
<tr class="memitem:a015eb1af78b29c2018f3635eb278ed0b template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a015eb1af78b29c2018f3635eb278ed0b">register_awaitable_rpc_handler</a> (<a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;grpc_context, detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;service, RPCHandler &amp;&amp;rpc_handler, CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:a015eb1af78b29c2018f3635eb278ed0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an awaitable rpc handler for the given method (<a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> overload)  <br /></td></tr>
<tr class="memitem:af2906310868898bd1069a922018033e5" id="r_af2906310868898bd1069a922018033e5"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class RPCHandler, class CompletionToken = detail::DefaultCompletionTokenT&lt;typename ServerRPC::executor_type&gt;&gt; </td></tr>
<tr class="memitem:af2906310868898bd1069a922018033e5 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2906310868898bd1069a922018033e5">register_callback_rpc_handler</a> (const typename ServerRPC::executor_type &amp;executor, detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;service, RPCHandler rpc_handler, CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:af2906310868898bd1069a922018033e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback rpc handler for the given method.  <br /></td></tr>
<tr class="memitem:a634945a9677aa2bb36b92252f3c854bf" id="r_a634945a9677aa2bb36b92252f3c854bf"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class RPCHandler, class CompletionToken&gt; </td></tr>
<tr class="memitem:a634945a9677aa2bb36b92252f3c854bf template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a634945a9677aa2bb36b92252f3c854bf">register_callback_rpc_handler</a> (<a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;grpc_context, detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;service, RPCHandler &amp;&amp;rpc_handler, CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:a634945a9677aa2bb36b92252f3c854bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback rpc handler for the given method (<a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> overload)  <br /></td></tr>
<tr class="memitem:a48edf641c6b8226ceebbd47688c6d369" id="r_a48edf641c6b8226ceebbd47688c6d369"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class CoroutineTraits, class RPCHandler, class CompletionToken = detail::DefaultCompletionTokenT&lt;typename ServerRPC::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a48edf641c6b8226ceebbd47688c6d369 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48edf641c6b8226ceebbd47688c6d369">register_coroutine_rpc_handler</a> (const typename ServerRPC::executor_type &amp;executor, detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;service, RPCHandler rpc_handler, CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a48edf641c6b8226ceebbd47688c6d369"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) Register a coroutine rpc handler for the given method  <br /></td></tr>
<tr class="memitem:a0fbe3a13a97f8f4de19a290ffaee43cb" id="r_a0fbe3a13a97f8f4de19a290ffaee43cb"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class CoroutineTraits, class RPCHandler, class CompletionToken&gt; </td></tr>
<tr class="memitem:a0fbe3a13a97f8f4de19a290ffaee43cb template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fbe3a13a97f8f4de19a290ffaee43cb">register_coroutine_rpc_handler</a> (<a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;grpc_context, detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;service, RPCHandler &amp;&amp;rpc_handler, CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:a0fbe3a13a97f8f4de19a290ffaee43cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) Register an coroutine rpc handler for the given method (<a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> overload)  <br /></td></tr>
<tr class="memitem:a595fc0d5c217d3d94d6d1dd230c09c39" id="r_a595fc0d5c217d3d94d6d1dd230c09c39"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class RPCHandler&gt; </td></tr>
<tr class="memitem:a595fc0d5c217d3d94d6d1dd230c09c39 template"><td class="memItemLeft" align="right" valign="top">detail::RPCHandlerSender&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, RPCHandler &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a595fc0d5c217d3d94d6d1dd230c09c39">register_sender_rpc_handler</a> (<a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;grpc_context, detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;service, RPCHandler rpc_handler)</td></tr>
<tr class="memdesc:a595fc0d5c217d3d94d6d1dd230c09c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a sender rpc handler for the given method.  <br /></td></tr>
<tr class="memitem:ac51d4bae04909dc6624b34e8931f4a6f" id="r_ac51d4bae04909dc6624b34e8931f4a6f"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class RPCHandler, class CompletionToken = detail::DefaultCompletionTokenT&lt;typename ServerRPC::executor_type&gt;&gt; </td></tr>
<tr class="memitem:ac51d4bae04909dc6624b34e8931f4a6f template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac51d4bae04909dc6624b34e8931f4a6f">register_yield_rpc_handler</a> (const typename ServerRPC::executor_type &amp;executor, detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;service, RPCHandler rpc_handler, CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:ac51d4bae04909dc6624b34e8931f4a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a Boost.Coroutine rpc handler for the given method.  <br /></td></tr>
<tr class="memitem:ac296ea567f88e9ccd85642736dcba97a" id="r_ac296ea567f88e9ccd85642736dcba97a"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class RPCHandler, class CompletionToken&gt; </td></tr>
<tr class="memitem:ac296ea567f88e9ccd85642736dcba97a template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac296ea567f88e9ccd85642736dcba97a">register_yield_rpc_handler</a> (<a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;grpc_context, detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;service, RPCHandler &amp;&amp;rpc_handler, CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:ac296ea567f88e9ccd85642736dcba97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a rpc handler for the given method (<a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> overload)  <br /></td></tr>
<tr class="memitem:ab52a5b6f6ce90d1bc9faa5baa96a39fa" id="r_ab52a5b6f6ce90d1bc9faa5baa96a39fa"><td class="memTemplParams" colspan="2">template&lt;class Traits = agrpc::DefaultRunTraits, class ExecutionContext = void&gt; </td></tr>
<tr class="memitem:ab52a5b6f6ce90d1bc9faa5baa96a39fa template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab52a5b6f6ce90d1bc9faa5baa96a39fa">run</a> (<a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;grpc_context, ExecutionContext &amp;execution_context)</td></tr>
<tr class="memdesc:ab52a5b6f6ce90d1bc9faa5baa96a39fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) Run an execution context in the same thread as a <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a>  <br /></td></tr>
<tr class="memitem:a075e15728ee3eac5531f3202cfaf6c38" id="r_a075e15728ee3eac5531f3202cfaf6c38"><td class="memTemplParams" colspan="2">template&lt;class Traits = agrpc::DefaultRunTraits, class ExecutionContext = void, class StopCondition = void&gt; </td></tr>
<tr class="memitem:a075e15728ee3eac5531f3202cfaf6c38 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a075e15728ee3eac5531f3202cfaf6c38">run</a> (<a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;grpc_context, ExecutionContext &amp;execution_context, StopCondition stop_condition)</td></tr>
<tr class="memdesc:a075e15728ee3eac5531f3202cfaf6c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) Run an execution context in the same thread as a <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a>  <br /></td></tr>
<tr class="memitem:a7c08e9c2d581c89024ba71489fc5aaf3" id="r_a7c08e9c2d581c89024ba71489fc5aaf3"><td class="memTemplParams" colspan="2">template&lt;class Traits = agrpc::DefaultRunTraits, class ExecutionContext = void&gt; </td></tr>
<tr class="memitem:a7c08e9c2d581c89024ba71489fc5aaf3 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c08e9c2d581c89024ba71489fc5aaf3">run_completion_queue</a> (<a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;grpc_context, ExecutionContext &amp;execution_context)</td></tr>
<tr class="memdesc:a7c08e9c2d581c89024ba71489fc5aaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) Run an execution context in the same thread as a <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a>'s completion queue  <br /></td></tr>
<tr class="memitem:a32f6562885c161c318d08f83e48468e8" id="r_a32f6562885c161c318d08f83e48468e8"><td class="memTemplParams" colspan="2">template&lt;class Traits = agrpc::DefaultRunTraits, class ExecutionContext = void, class StopCondition = void&gt; </td></tr>
<tr class="memitem:a32f6562885c161c318d08f83e48468e8 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32f6562885c161c318d08f83e48468e8">run_completion_queue</a> (<a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;grpc_context, ExecutionContext &amp;execution_context, StopCondition stop_condition)</td></tr>
<tr class="memdesc:a32f6562885c161c318d08f83e48468e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(experimental) Run an execution context in the same thread as a <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a>'s completion queue  <br /></td></tr>
<tr class="memitem:accc81e3886098f4472dbe3e528594e3e" id="r_accc81e3886098f4472dbe3e528594e3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accc81e3886098f4472dbe3e528594e3e">process_grpc_tag</a> (<a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;grpc_context, void *tag, bool ok)</td></tr>
<tr class="memdesc:accc81e3886098f4472dbe3e528594e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test utility to manually process gRPC tags.  <br /></td></tr>
<tr class="memitem:a886bd0e1412d8fc13ca2a5959aab07fb" id="r_a886bd0e1412d8fc13ca2a5959aab07fb"><td class="memItemLeft" align="right" valign="top">grpc::ServerBuilder &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_health_check_service.html#a886bd0e1412d8fc13ca2a5959aab07fb">add_health_check_service</a> (grpc::ServerBuilder &amp;builder)</td></tr>
<tr class="memdesc:a886bd0e1412d8fc13ca2a5959aab07fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="classagrpc_1_1_health_check_service.html" title="CompletionQueue-based implementation of grpc::HealthCheckServiceInterface.">HealthCheckService</a> to a <span class="tt">grpc::Server</span>  <br /></td></tr>
<tr class="memitem:a7a1da8eae5be01bec3a8f6a8be75932f" id="r_a7a1da8eae5be01bec3a8f6a8be75932f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_health_check_service.html#a7a1da8eae5be01bec3a8f6a8be75932f">start_health_check_service</a> (<a class="el" href="classagrpc_1_1_health_check_service.html">agrpc::HealthCheckService</a> &amp;service, <a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;grpc_context)</td></tr>
<tr class="memdesc:a7a1da8eae5be01bec3a8f6a8be75932f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a previously added <a class="el" href="classagrpc_1_1_health_check_service.html" title="CompletionQueue-based implementation of grpc::HealthCheckServiceInterface.">HealthCheckService</a>.  <br /></td></tr>
<tr class="memitem:a55f352e270845728106e5dd3da20e668" id="r_a55f352e270845728106e5dd3da20e668"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1_health_check_service.html#a55f352e270845728106e5dd3da20e668">start_health_check_service</a> (grpc::Server &amp;server, <a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;grpc_context)</td></tr>
<tr class="memdesc:a55f352e270845728106e5dd3da20e668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a previously added <a class="el" href="classagrpc_1_1_health_check_service.html" title="CompletionQueue-based implementation of grpc::HealthCheckServiceInterface.">HealthCheckService</a> (<span class="tt">grpc::Server</span> overload)  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3f3ac92b1e47fe65b8bbef1b3af97c60" id="r_a3f3ac92b1e47fe65b8bbef1b3af97c60"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structagrpc_1_1detail_1_1_notify_on_state_change_fn.html">detail::NotifyOnStateChangeFn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f3ac92b1e47fe65b8bbef1b3af97c60">notify_on_state_change</a> {}</td></tr>
<tr class="memdesc:a3f3ac92b1e47fe65b8bbef1b3af97c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set notification for a <span class="tt">grpc::Channel</span> state change.  <br /></td></tr>
<tr class="memitem:a685510388ab87c9a90c44f880e9de9cd" id="r_a685510388ab87c9a90c44f880e9de9cd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structagrpc_1_1detail_1_1_read_fn.html">detail::ReadFn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a685510388ab87c9a90c44f880e9de9cd">read</a> {}</td></tr>
<tr class="memdesc:a685510388ab87c9a90c44f880e9de9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a streaming RPC.  <br /></td></tr>
<tr class="memitem:aa9c38be6a3d7d59a78007bc4fff311a4" id="r_aa9c38be6a3d7d59a78007bc4fff311a4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structagrpc_1_1_use_sender.html">agrpc::UseSender</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9c38be6a3d7d59a78007bc4fff311a4">use_sender</a> {}</td></tr>
<tr class="memdesc:aa9c38be6a3d7d59a78007bc4fff311a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance and factory for sender completion tokens.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Public namespace. </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ad6c406cc03ead4c6f180bdf56bff6a03" name="ad6c406cc03ead4c6f180bdf56bff6a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c406cc03ead4c6f180bdf56bff6a03">&#9670;&#160;</a></span>Alarm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad6c406cc03ead4c6f180bdf56bff6a03">agrpc::Alarm</a> = <a class="el" href="classagrpc_1_1_basic_alarm.html">agrpc::BasicAlarm</a>&lt;<a class="el" href="#a03ba541ef9c0352e6160442780e533b4">agrpc::GrpcExecutor</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classagrpc_1_1_basic_alarm.html" title="I/O object for grpc::Alarm">BasicAlarm</a> that uses <span class="tt"><a class="el" href="#a03ba541ef9c0352e6160442780e533b4" title="Default GrpcExecutor.">agrpc::GrpcExecutor</a></span> </p>
<dl class="section since"><dt>Since</dt><dd>2.2.0 </dd></dl>

</div>
</div>
<a id="a25a436b55412d2716c905ce0522bd84c" name="a25a436b55412d2716c905ce0522bd84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a436b55412d2716c905ce0522bd84c">&#9670;&#160;</a></span>GenericUnaryClientRPC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a25a436b55412d2716c905ce0522bd84c">agrpc::GenericUnaryClientRPC</a> = <a class="el" href="classagrpc_1_1_client_r_p_c.html">agrpc::ClientRPC</a>&lt;<a class="el" href="#a42c57be5049212df6909b6da0c60d36ea2a1be6738d2573a3eecd21f772e11756">agrpc::ClientRPCType::GENERIC_UNARY</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O object for client-side, generic, unary rpcs (type alias) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classagrpc_1_1_client_r_p_c_3_01agrpc_1_1_client_r_p_c_type_1_1_g_e_n_e_r_i_c___u_n_a_r_y_00_01_executor_01_4.html" title="I/O object for client-side, generic, unary rpcs.">agrpc::ClientRPC&lt;agrpc::ClientRPCType::GENERIC_UNARY,Executor&gt;</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="a644b312cfc6e64a0e50ab525cb095077" name="a644b312cfc6e64a0e50ab525cb095077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644b312cfc6e64a0e50ab525cb095077">&#9670;&#160;</a></span>GenericStreamingClientRPC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a644b312cfc6e64a0e50ab525cb095077">agrpc::GenericStreamingClientRPC</a> = <a class="el" href="classagrpc_1_1_client_r_p_c.html">agrpc::ClientRPC</a>&lt;<a class="el" href="#a42c57be5049212df6909b6da0c60d36eadf49273525fcac45f0fe3afd8c7a5454">agrpc::ClientRPCType::GENERIC_STREAMING</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O object for client-side, generic, streaming rpcs (type alias) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classagrpc_1_1_client_r_p_c.html" title="Primary ClientRPC template.">agrpc::ClientRPC&lt;agrpc::ClientRPCType::GENERIC_STREAMING,Executor&gt;</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="a03ba541ef9c0352e6160442780e533b4" name="a03ba541ef9c0352e6160442780e533b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ba541ef9c0352e6160442780e533b4">&#9670;&#160;</a></span>GrpcExecutor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a03ba541ef9c0352e6160442780e533b4">agrpc::GrpcExecutor</a> = <a class="el" href="classagrpc_1_1_basic_grpc_executor.html">agrpc::BasicGrpcExecutor</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default <a class="el" href="#a03ba541ef9c0352e6160442780e533b4" title="Default GrpcExecutor.">GrpcExecutor</a>. </p>
<p>The default <a class="el" href="#a03ba541ef9c0352e6160442780e533b4" title="Default GrpcExecutor.">GrpcExecutor</a> does not track outstanding work, has the <a href="https://www.boost.org/doc/libs/1_86_0/doc/html/boost_asio/reference/execution__relationship_t__fork_t.html">relationship.fork</a> and <a href="https://www.boost.org/doc/libs/1_86_0/doc/html/boost_asio/reference/execution__blocking_t__never_t.html">blocking.never</a> properties and uses the default allocator (<span class="tt">std::allocator&lt;void&gt;</span>). </p>

</div>
</div>
<a id="a7d5eebaa6f815abd3ae12325f88fd253" name="a7d5eebaa6f815abd3ae12325f88fd253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5eebaa6f815abd3ae12325f88fd253">&#9670;&#160;</a></span>GenericServerRPC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7d5eebaa6f815abd3ae12325f88fd253">agrpc::GenericServerRPC</a> = <a class="el" href="classagrpc_1_1_server_r_p_c.html">agrpc::ServerRPC</a>&lt;<a class="el" href="#a819aed2748e29d498c18adfcc5855216ac942dc2a9f958acddc67e11472d3ca0b">agrpc::ServerRPCType::GENERIC</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O object for server-side, generic rpcs (type alias) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classagrpc_1_1_server_r_p_c_3_01agrpc_1_1_server_r_p_c_type_1_1_g_e_n_e_r_i_c_00_01_traits_t_00_01_executor_01_4.html" title="I/O object for server-side, generic rpcs.">agrpc::ServerRPC&lt;agrpc::ServerRPCType::GENERIC,TraitsT,Executor&gt;</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.7.0 </dd></dl>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a42c57be5049212df6909b6da0c60d36e" name="a42c57be5049212df6909b6da0c60d36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c57be5049212df6909b6da0c60d36e">&#9670;&#160;</a></span>ClientRPCType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a42c57be5049212df6909b6da0c60d36e">agrpc::ClientRPCType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of a <a class="el" href="classagrpc_1_1_client_r_p_c.html" title="Primary ClientRPC template.">ClientRPC</a>. </p>
<dl class="section since"><dt>Since</dt><dd>2.1.0 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a42c57be5049212df6909b6da0c60d36ea8ca44f46ef1f04b2113678603c3800b4" name="a42c57be5049212df6909b6da0c60d36ea8ca44f46ef1f04b2113678603c3800b4"></a>UNARY&#160;</td><td class="fielddoc"><p>Client-side unary rpc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a42c57be5049212df6909b6da0c60d36ea2a1be6738d2573a3eecd21f772e11756" name="a42c57be5049212df6909b6da0c60d36ea2a1be6738d2573a3eecd21f772e11756"></a>GENERIC_UNARY&#160;</td><td class="fielddoc"><p>Client-side generic unary rpc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a42c57be5049212df6909b6da0c60d36eaeb1bcff53747fbcc6c2ded49b5724257" name="a42c57be5049212df6909b6da0c60d36eaeb1bcff53747fbcc6c2ded49b5724257"></a>SERVER_STREAMING&#160;</td><td class="fielddoc"><p>Client-side server-streaming rpc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a42c57be5049212df6909b6da0c60d36ea1350d72153c5dd5e5cbaffc22da1cfdc" name="a42c57be5049212df6909b6da0c60d36ea1350d72153c5dd5e5cbaffc22da1cfdc"></a>CLIENT_STREAMING&#160;</td><td class="fielddoc"><p>Client-side client-streaming rpc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a42c57be5049212df6909b6da0c60d36eaf92e0d805b776fa75c63d16707f99111" name="a42c57be5049212df6909b6da0c60d36eaf92e0d805b776fa75c63d16707f99111"></a>BIDIRECTIONAL_STREAMING&#160;</td><td class="fielddoc"><p>Client-side bidirectional-streaming rpc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a42c57be5049212df6909b6da0c60d36eadf49273525fcac45f0fe3afd8c7a5454" name="a42c57be5049212df6909b6da0c60d36eadf49273525fcac45f0fe3afd8c7a5454"></a>GENERIC_STREAMING&#160;</td><td class="fielddoc"><p>Client-side generic streaming rpc. </p>
</td></tr>
</table>

</div>
</div>
<a id="a819aed2748e29d498c18adfcc5855216" name="a819aed2748e29d498c18adfcc5855216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819aed2748e29d498c18adfcc5855216">&#9670;&#160;</a></span>ServerRPCType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a819aed2748e29d498c18adfcc5855216">agrpc::ServerRPCType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of a <a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a>. </p>
<dl class="section since"><dt>Since</dt><dd>2.7.0 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a819aed2748e29d498c18adfcc5855216a8ca44f46ef1f04b2113678603c3800b4" name="a819aed2748e29d498c18adfcc5855216a8ca44f46ef1f04b2113678603c3800b4"></a>UNARY&#160;</td><td class="fielddoc"><p>Server-side unary rpc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a819aed2748e29d498c18adfcc5855216aeb1bcff53747fbcc6c2ded49b5724257" name="a819aed2748e29d498c18adfcc5855216aeb1bcff53747fbcc6c2ded49b5724257"></a>SERVER_STREAMING&#160;</td><td class="fielddoc"><p>Server-side server-streaming rpc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a819aed2748e29d498c18adfcc5855216a1350d72153c5dd5e5cbaffc22da1cfdc" name="a819aed2748e29d498c18adfcc5855216a1350d72153c5dd5e5cbaffc22da1cfdc"></a>CLIENT_STREAMING&#160;</td><td class="fielddoc"><p>Server-side client-streaming rpc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a819aed2748e29d498c18adfcc5855216af92e0d805b776fa75c63d16707f99111" name="a819aed2748e29d498c18adfcc5855216af92e0d805b776fa75c63d16707f99111"></a>BIDIRECTIONAL_STREAMING&#160;</td><td class="fielddoc"><p>Server-side bidirectional-streaming rpc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a819aed2748e29d498c18adfcc5855216ac942dc2a9f958acddc67e11472d3ca0b" name="a819aed2748e29d498c18adfcc5855216ac942dc2a9f958acddc67e11472d3ca0b"></a>GENERIC&#160;</td><td class="fielddoc"><p>Server-side generic streaming rpc. </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a91f47317f73d2a74002922459fd283fb" name="a91f47317f73d2a74002922459fd283fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f47317f73d2a74002922459fd283fb">&#9670;&#160;</a></span>unary_call()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StubAsync, class Request, class Response, class CompletionToken = detail::DefaultCompletionTokenT&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::unary_call </td>
          <td>(</td>
          <td class="paramtype">detail::AsyncUnaryFn&lt; StubAsync, Request, Response &gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StubAsync *</td>          <td class="paramname"><span class="paramname"><em>stub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">grpc::ClientContext &amp;</td>          <td class="paramname"><span class="paramname"><em>client_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Request &amp;</td>          <td class="paramname"><span class="paramname"><em>req</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Response &amp;</td>          <td class="paramname"><span class="paramname"><em>response</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(experimental) Perform a unary rpc </p>
<p>Completion signature is <span class="tt">void(error_code, grpc::Status)</span>. Once this operation completes the response passed to it will have been be populated if <span class="tt">grpc::Status::ok()</span> is true.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="#a91f47317f73d2a74002922459fd283fb">unary_call</a>(example::v1::Example::Stub&amp; stub, example::v1::Request request)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> state = std::make_unique&lt;std::tuple&lt;example::v1::Request, grpc::ClientContext, example::v1::Response&gt;&gt;();</div>
<div class="line">    <span class="keyword">auto</span>&amp; [req, context, rsp] = *state;</div>
<div class="line">    req = std::move(request);</div>
<div class="line">    <a class="code hl_function" href="#a91f47317f73d2a74002922459fd283fb">agrpc::unary_call</a>(&amp;example::v1::Example::Stub::async::Unary, stub.async(), context, req, rsp,</div>
<div class="line">                      [state = std::move(state)](<span class="keyword">const</span> grpc::Status&amp; <span class="comment">/*status*/</span>) {});</div>
<div class="line">}</div>
</div><!-- fragment --><p>Based on <span class="tt">.proto</span> file:</p>
<div class="fragment"><div class="line">syntax = &quot;proto3&quot;;</div>
<div class="line"> </div>
<div class="line">package example.v1;</div>
<div class="line"> </div>
<div class="line">service Example {</div>
<div class="line">  rpc ServerStreaming(Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc ClientStreaming(stream Request) returns (Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc BidirectionalStreaming(stream Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc Unary(Request) returns (Response) {}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Request {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Response {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Per-Operation Cancellation</b></p>
<p>None (still in development)</p>
<dl class="section since"><dt>Since</dt><dd>3.5.0 </dd></dl>

</div>
</div>
<a id="a0704072818e6d125ef22b0ae1bbe324e" name="a0704072818e6d125ef22b0ae1bbe324e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0704072818e6d125ef22b0ae1bbe324e">&#9670;&#160;</a></span>allocate_reactor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Reactor, class Allocator, class... Args, class = std::enable_if_t&lt;!std::is_same_v&lt;void, detail::ReactorExecutorTypeT&lt;Reactor&gt;&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::allocate_reactor </td>
          <td>(</td>
          <td class="paramtype">Allocator</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::ReactorExecutorTypeT&lt; Reactor &gt;</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create <a class="el" href="classagrpc_1_1_reactor_ptr.html" title="Shared pointer-like object for reactors.">ReactorPtr</a> using allocator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reactor</td><td>The reactor type like <span class="tt"><a class="el" href="#a41df67b4a7412df071a87b872347cf86" title="(experimental) I/O object for server-side, unary rpcs (specialized on asio::any_io_executor)">agrpc::ServerUnaryReactor</a></span>, <span class="tt"><a class="el" href="#a40bf242fb8bf95903420b1c2188a4a62" title="(experimental) I/O object for client-side, unary rpcs (specialized on asio::any_io_executor)">agrpc::ClientUnaryReactor</a></span> or a class derived from their base equivalents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>3.5.0 </dd></dl>

</div>
</div>
<a id="a737b02be94cff8e511123b630f1fff79" name="a737b02be94cff8e511123b630f1fff79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737b02be94cff8e511123b630f1fff79">&#9670;&#160;</a></span>allocate_reactor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Reactor, class Allocator, class... Args, class = std::enable_if_t&lt;std::is_same_v&lt;void, detail::ReactorExecutorTypeT&lt;Reactor&gt;&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classagrpc_1_1_reactor_ptr.html">ReactorPtr</a>&lt; Reactor &gt; agrpc::allocate_reactor </td>
          <td>(</td>
          <td class="paramtype">Allocator</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create <a class="el" href="classagrpc_1_1_reactor_ptr.html" title="Shared pointer-like object for reactors.">ReactorPtr</a> using allocator (sender/receiver overload) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reactor</td><td>The reactor type like <span class="tt"><a class="el" href="#a41df67b4a7412df071a87b872347cf86" title="(experimental) I/O object for server-side, unary rpcs (specialized on asio::any_io_executor)">agrpc::ServerUnaryReactor</a></span>, <span class="tt"><a class="el" href="#a40bf242fb8bf95903420b1c2188a4a62" title="(experimental) I/O object for client-side, unary rpcs (specialized on asio::any_io_executor)">agrpc::ClientUnaryReactor</a></span> or a class derived from their base equivalents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>3.5.0 </dd></dl>

</div>
</div>
<a id="a59ca62564b50007b111375aa090e752b" name="a59ca62564b50007b111375aa090e752b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ca62564b50007b111375aa090e752b">&#9670;&#160;</a></span>make_reactor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Reactor, class... Args, class = std::enable_if_t&lt;!std::is_same_v&lt;void, detail::ReactorExecutorTypeT&lt;Reactor&gt;&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classagrpc_1_1_reactor_ptr.html">ReactorPtr</a>&lt; Reactor &gt; agrpc::make_reactor </td>
          <td>(</td>
          <td class="paramtype">detail::ReactorExecutorTypeT&lt; Reactor &gt;</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create <a class="el" href="classagrpc_1_1_reactor_ptr.html" title="Shared pointer-like object for reactors.">ReactorPtr</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reactor</td><td>The reactor type like <span class="tt"><a class="el" href="#a41df67b4a7412df071a87b872347cf86" title="(experimental) I/O object for server-side, unary rpcs (specialized on asio::any_io_executor)">agrpc::ServerUnaryReactor</a></span>, <span class="tt"><a class="el" href="#a40bf242fb8bf95903420b1c2188a4a62" title="(experimental) I/O object for client-side, unary rpcs (specialized on asio::any_io_executor)">agrpc::ClientUnaryReactor</a></span> or a class derived from their base equivalents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>3.5.0 </dd></dl>

</div>
</div>
<a id="a76ba647b5fba8b9ddeb615be745cabbb" name="a76ba647b5fba8b9ddeb615be745cabbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ba647b5fba8b9ddeb615be745cabbb">&#9670;&#160;</a></span>make_reactor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Reactor, class... Args, class = std::enable_if_t&lt;std::is_same_v&lt;void, detail::ReactorExecutorTypeT&lt;Reactor&gt;&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classagrpc_1_1_reactor_ptr.html">ReactorPtr</a>&lt; Reactor &gt; agrpc::make_reactor </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create <a class="el" href="classagrpc_1_1_reactor_ptr.html" title="Shared pointer-like object for reactors.">ReactorPtr</a> (sender/receiver overload) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reactor</td><td>The reactor type like <span class="tt"><a class="el" href="#a41df67b4a7412df071a87b872347cf86" title="(experimental) I/O object for server-side, unary rpcs (specialized on asio::any_io_executor)">agrpc::ServerUnaryReactor</a></span>, <span class="tt"><a class="el" href="#a40bf242fb8bf95903420b1c2188a4a62" title="(experimental) I/O object for client-side, unary rpcs (specialized on asio::any_io_executor)">agrpc::ClientUnaryReactor</a></span> or a class derived from their base equivalents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>3.5.0 </dd></dl>

</div>
</div>
<a id="ae09f3bd4a00ce92682d30395d1fba52f" name="ae09f3bd4a00ce92682d30395d1fba52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09f3bd4a00ce92682d30395d1fba52f">&#9670;&#160;</a></span>register_awaitable_rpc_handler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class RPCHandler, class CompletionToken = detail::DefaultCompletionTokenT&lt;typename ServerRPC::executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::register_awaitable_rpc_handler </td>
          <td>(</td>
          <td class="paramtype">const typename ServerRPC::executor_type &amp;</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>service</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RPCHandler</td>          <td class="paramname"><span class="paramname"><em>rpc_handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an awaitable rpc handler for the given method. </p>
<p>The rpc handler will be invoked for every incoming request of this gRPC method. It must take <span class="tt"><a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a>&amp;</span> as first argument and <span class="tt">ServerRPC::Request&amp;</span> as second argument (only for unary and server-streaming rpcs). The <a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a> is automatically cancelled at the end of the rpc handler if <span class="tt">finish()</span> was not called earlier. The return value of the rpc handler is <span class="tt">co_spawn</span>ed in a manner similar to: <span class="tt">asio::co_spawn(asio::get_associated_executor(completion_handler, executor), rpc_handler)</span>, where <span class="tt">completion_handler</span> is created from <span class="tt">token</span> and <span class="tt">executor</span> the first argument passed to this function.</p>
<p>This asynchronous operation runs forever unless it is cancelled, the rpc handler throws an exception or the server is shutdown (<a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_server_interface.html#a6a1d337270116c95f387e0abf01f6c6c">grpc::Server::Shutdown</a> is called). At which point it invokes the completion handler (passing forward the exception thrown by the request handler, if any) after all awaitables produced by invoking the rpc handler complete.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> server_rpc_unary(<a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a>&amp; grpc_context,</div>
<div class="line">                      example::v1::Example::AsyncService&amp; service)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>RPC = <a class="code hl_class" href="classagrpc_1_1_server_r_p_c.html">agrpc::ServerRPC&lt;&amp;example::v1::Example::AsyncService::RequestUnary&gt;</a>;</div>
<div class="line">    <a class="code hl_function" href="#ae09f3bd4a00ce92682d30395d1fba52f">agrpc::register_awaitable_rpc_handler&lt;RPC&gt;</a>(</div>
<div class="line">        grpc_context, service,</div>
<div class="line">        [](RPC&amp; rpc, RPC::Request&amp; request) -&gt; asio::awaitable&lt;void&gt;</div>
<div class="line">        {</div>
<div class="line">            RPC::Response response;</div>
<div class="line">            response.set_integer(request.integer());</div>
<div class="line">            <span class="keyword">co_await</span> rpc.finish(response, grpc::Status::OK);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Alternatively finish with an error:</span></div>
<div class="line">            <span class="keyword">co_await</span> rpc.finish_with_error(grpc::Status::CANCELLED);</div>
<div class="line">        },</div>
<div class="line">        asio::detached);</div>
<div class="line">}</div>
</div><!-- fragment --><p>[(experimental) Additionally, the rpc handler may have a method called <span class="tt">request_message_factory()</span>. If it does then that method will be invoked and the returned object used to create and destroy the initial request message for unary and server-streaming rpcs.</p>
<p>Example: (since 3.4.0)]</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ArenaRequestMessageFactory</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Request&gt;</div>
<div class="line">    Request&amp; create()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> *google::protobuf::Arena::Create&lt;Request&gt;(&amp;arena_);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This method is optional and can be omitted</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Request&gt;</div>
<div class="line">    <span class="keywordtype">void</span> destroy(Request&amp;) <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    google::protobuf::Arena arena_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Handler&gt;</div>
<div class="line"><span class="keyword">class </span>RPCHandlerWithArenaRequestMessageFactory</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> RPCHandlerWithArenaRequestMessageFactory(Handler handler) : handler_(std::move(handler)) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) operator()(Args&amp;&amp;... args)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// for unary and server-streaming rpcs args are: ServerRPC&amp;, Request&amp;,</span></div>
<div class="line">        <span class="comment">// ArenaRequestMessageFactory&amp;</span></div>
<div class="line">        <span class="keywordflow">return</span> handler_(std::forward&lt;Args&gt;(args)...);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ArenaRequestMessageFactory request_message_factory() { <span class="keywordflow">return</span> {}; }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    Handler handler_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ServerRPC, <span class="keyword">class</span> RPCHandler&gt;</div>
<div class="line"><span class="keywordtype">void</span> register_rpc_handler(<a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a>&amp; grpc_context, example::v1::Example::AsyncService&amp; service,</div>
<div class="line">                          RPCHandler&amp;&amp; handler)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="#ae09f3bd4a00ce92682d30395d1fba52f">agrpc::register_awaitable_rpc_handler&lt;ServerRPC&gt;</a>(</div>
<div class="line">        grpc_context, service, RPCHandlerWithArenaRequestMessageFactory{std::forward&lt;RPCHandler&gt;(handler)},</div>
<div class="line">        asio::detached);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a></td><td>An instantiation of <span class="tt"><a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">agrpc::ServerRPC</a></span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>The executor used to handle each rpc </td></tr>
    <tr><td class="paramname">service</td><td>The service associated with the gRPC method of the <a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a> </td></tr>
    <tr><td class="paramname">rpc_handler</td><td>A callable that produces an <span class="tt">asio::awaitable&lt;void, Executor&gt;</span>. The awaitable's return value is ignored. The Executor must be constructible from <span class="tt">asio::get_associated_executor(completion_handler,
executor)</span>, where <span class="tt">completion_handler</span> is obtained from <span class="tt">token</span> and <span class="tt">executor</span> the first argument passed to this function. </td></tr>
    <tr><td class="paramname">token</td><td>A completion token for signature <span class="tt">void(std::exception_ptr)</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.7.0 </dd></dl>

</div>
</div>
<a id="a015eb1af78b29c2018f3635eb278ed0b" name="a015eb1af78b29c2018f3635eb278ed0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015eb1af78b29c2018f3635eb278ed0b">&#9670;&#160;</a></span>register_awaitable_rpc_handler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class RPCHandler, class CompletionToken&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::register_awaitable_rpc_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grpc_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>service</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RPCHandler &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rpc_handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an awaitable rpc handler for the given method (<a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> overload) </p>
<dl class="section since"><dt>Since</dt><dd>2.7.0 </dd></dl>

</div>
</div>
<a id="af2906310868898bd1069a922018033e5" name="af2906310868898bd1069a922018033e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2906310868898bd1069a922018033e5">&#9670;&#160;</a></span>register_callback_rpc_handler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class RPCHandler, class CompletionToken = detail::DefaultCompletionTokenT&lt;typename ServerRPC::executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::register_callback_rpc_handler </td>
          <td>(</td>
          <td class="paramtype">const typename ServerRPC::executor_type &amp;</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>service</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RPCHandler</td>          <td class="paramname"><span class="paramname"><em>rpc_handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a callback rpc handler for the given method. </p>
<p>The rpc handler will be invoked for every incoming request of this gRPC method. It must take <span class="tt">ServerRPC::Ptr</span> as first and <span class="tt">ServerRPC::Request&amp;</span> as second (only for unary and server-streaming rpcs) argument. The <a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a> is automatically cancelled during destruction of the <span class="tt">ServerRPC::Ptr</span> if <span class="tt">finish()</span> was not called earlier.</p>
<p>This asynchronous operation runs forever unless it is cancelled, the rpc handler throws an exception or the server is shutdown (<a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_server_interface.html#a6a1d337270116c95f387e0abf01f6c6c">grpc::Server::Shutdown</a> is called). At which point it invokes the completion handler (passing forward the exception thrown by the request handler, if any) after all <span class="tt">ServerRPC::Ptr</span>s have been destructed.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> server_rpc_unary_callback(<a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a>&amp; grpc_context, example::v1::Example::AsyncService&amp; service)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>RPC = <a class="code hl_class" href="classagrpc_1_1_server_r_p_c.html">agrpc::ServerRPC&lt;&amp;example::v1::Example::AsyncService::RequestUnary&gt;</a>;</div>
<div class="line">    <a class="code hl_function" href="#af2906310868898bd1069a922018033e5">agrpc::register_callback_rpc_handler&lt;RPC&gt;</a>(</div>
<div class="line">        grpc_context, service,</div>
<div class="line">        [](RPC::Ptr ptr, RPC::Request&amp; request)</div>
<div class="line">        {</div>
<div class="line">            RPC::Response response;</div>
<div class="line">            response.set_integer(request.integer());</div>
<div class="line">            <span class="keyword">auto</span>&amp; rpc = *ptr;</div>
<div class="line">            rpc.finish(response, grpc::Status::OK, [p = std::move(ptr)](<span class="keywordtype">bool</span>) {});</div>
<div class="line">        },</div>
<div class="line">        asio::detached);</div>
<div class="line">}</div>
</div><!-- fragment --><p>[(experimental) Additionally, the rpc handler may have a method called <span class="tt">request_message_factory()</span>. If it does then that method will be invoked and the returned object used to create and destroy the initial request message for unary and server-streaming rpcs.</p>
<p>Example: (since 3.4.0)]</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ArenaRequestMessageFactory</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Request&gt;</div>
<div class="line">    Request&amp; create()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> *google::protobuf::Arena::Create&lt;Request&gt;(&amp;arena_);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This method is optional and can be omitted</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Request&gt;</div>
<div class="line">    <span class="keywordtype">void</span> destroy(Request&amp;) <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    google::protobuf::Arena arena_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Handler&gt;</div>
<div class="line"><span class="keyword">class </span>RPCHandlerWithArenaRequestMessageFactory</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> RPCHandlerWithArenaRequestMessageFactory(Handler handler) : handler_(std::move(handler)) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) operator()(Args&amp;&amp;... args)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// for unary and server-streaming rpcs args are: ServerRPC&amp;, Request&amp;,</span></div>
<div class="line">        <span class="comment">// ArenaRequestMessageFactory&amp;</span></div>
<div class="line">        <span class="keywordflow">return</span> handler_(std::forward&lt;Args&gt;(args)...);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ArenaRequestMessageFactory request_message_factory() { <span class="keywordflow">return</span> {}; }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    Handler handler_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ServerRPC, <span class="keyword">class</span> RPCHandler&gt;</div>
<div class="line"><span class="keywordtype">void</span> register_rpc_handler(<a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a>&amp; grpc_context, example::v1::Example::AsyncService&amp; service,</div>
<div class="line">                          RPCHandler&amp;&amp; handler)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="#ae09f3bd4a00ce92682d30395d1fba52f">agrpc::register_awaitable_rpc_handler&lt;ServerRPC&gt;</a>(</div>
<div class="line">        grpc_context, service, RPCHandlerWithArenaRequestMessageFactory{std::forward&lt;RPCHandler&gt;(handler)},</div>
<div class="line">        asio::detached);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a></td><td>An instantiation of <span class="tt"><a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">agrpc::ServerRPC</a></span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>The executor used to handle each rpc </td></tr>
    <tr><td class="paramname">service</td><td>The service associated with the gRPC method of the <a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a> </td></tr>
    <tr><td class="paramname">rpc_handler</td><td>A callable that handles the client's request </td></tr>
    <tr><td class="paramname">token</td><td>A completion token for signature <span class="tt">void(std::exception_ptr)</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="a634945a9677aa2bb36b92252f3c854bf" name="a634945a9677aa2bb36b92252f3c854bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634945a9677aa2bb36b92252f3c854bf">&#9670;&#160;</a></span>register_callback_rpc_handler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class RPCHandler, class CompletionToken&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::register_callback_rpc_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grpc_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>service</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RPCHandler &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rpc_handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a callback rpc handler for the given method (<a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> overload) </p>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="a48edf641c6b8226ceebbd47688c6d369" name="a48edf641c6b8226ceebbd47688c6d369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48edf641c6b8226ceebbd47688c6d369">&#9670;&#160;</a></span>register_coroutine_rpc_handler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class CoroutineTraits, class RPCHandler, class CompletionToken = detail::DefaultCompletionTokenT&lt;typename ServerRPC::executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::register_coroutine_rpc_handler </td>
          <td>(</td>
          <td class="paramtype">const typename ServerRPC::executor_type &amp;</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>service</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RPCHandler</td>          <td class="paramname"><span class="paramname"><em>rpc_handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(experimental) Register a coroutine rpc handler for the given method </p>
<p>The rpc handler will be invoked for every incoming request of this gRPC method. It must take <span class="tt"><a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a>&amp;</span> as first argument and <span class="tt">ServerRPC::Request&amp;</span> as second argument (only for unary and server-streaming rpcs). The <a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a> is automatically cancelled at the end of the rpc handler if <span class="tt">finish()</span> was not called earlier. The return value of the rpc handler is <span class="tt">co_spawn</span>ed in a manner similar to: <span class="tt">CoroutineTraits::co_spawn(executor, rpc_handler, completion_handler, function)</span>, where <span class="tt">completion_handler</span> is created from <span class="tt">token</span>, <span class="tt">executor</span> the first argument passed to this function and <span class="tt">function</span>, when invoked, starts waiting for the next rpc. Any arguments passed to <span class="tt">function</span> will be prepended to the call of the rpc handler. The return type of <span class="tt">function</span> is <span class="tt">CoroutineTraits::ReturnType</span>, which must be a coroutine, and <span class="tt">CoroutineTraits::completion_token</span> must produce an Asio compatible <a href="https://www.boost.org/doc/libs/1_86_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.completion_tokens_and_handlers">completion token</a> that, when used to initiate an asynchronous operation, returns an awaitable.</p>
<p>This asynchronous operation runs forever unless it is cancelled, the rpc handler throws an exception or the server is shutdown (<a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_server_interface.html#a6a1d337270116c95f387e0abf01f6c6c">grpc::Server::Shutdown</a> is called). At which point it invokes the completion handler (passing forward the exception thrown by the request handler, if any) after all coroutines produced by invoking the rpc handler complete.</p>
<p>[(experimental) Additionally, the rpc handler may have a method called <span class="tt">request_message_factory()</span>. If it does then that method will be invoked and the returned object used to create and destroy the initial request message for unary and server-streaming rpcs.</p>
<p>Example: (since 3.4.0)]</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ArenaRequestMessageFactory</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Request&gt;</div>
<div class="line">    Request&amp; create()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> *google::protobuf::Arena::Create&lt;Request&gt;(&amp;arena_);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This method is optional and can be omitted</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Request&gt;</div>
<div class="line">    <span class="keywordtype">void</span> destroy(Request&amp;) <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    google::protobuf::Arena arena_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Handler&gt;</div>
<div class="line"><span class="keyword">class </span>RPCHandlerWithArenaRequestMessageFactory</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> RPCHandlerWithArenaRequestMessageFactory(Handler handler) : handler_(std::move(handler)) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) operator()(Args&amp;&amp;... args)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// for unary and server-streaming rpcs args are: ServerRPC&amp;, Request&amp;,</span></div>
<div class="line">        <span class="comment">// ArenaRequestMessageFactory&amp;</span></div>
<div class="line">        <span class="keywordflow">return</span> handler_(std::forward&lt;Args&gt;(args)...);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ArenaRequestMessageFactory request_message_factory() { <span class="keywordflow">return</span> {}; }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    Handler handler_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ServerRPC, <span class="keyword">class</span> RPCHandler&gt;</div>
<div class="line"><span class="keywordtype">void</span> register_rpc_handler(<a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a>&amp; grpc_context, example::v1::Example::AsyncService&amp; service,</div>
<div class="line">                          RPCHandler&amp;&amp; handler)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="#ae09f3bd4a00ce92682d30395d1fba52f">agrpc::register_awaitable_rpc_handler&lt;ServerRPC&gt;</a>(</div>
<div class="line">        grpc_context, service, RPCHandlerWithArenaRequestMessageFactory{std::forward&lt;RPCHandler&gt;(handler)},</div>
<div class="line">        asio::detached);</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a></td><td>An instantiation of <span class="tt"><a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">agrpc::ServerRPC</a></span> </td></tr>
    <tr><td class="paramname">CoroutineTraits</td><td>A class that provides functions for spawning the coroutine of each rpc. Example:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Executor = boost::asio::any_io_executor, <span class="keyword">class</span> Allocator = std::allocator&lt;<span class="keywordtype">void</span>&gt;&gt;</div>
<div class="line"><span class="keyword">struct </span>AsioCoroTraits</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>ReturnType = boost::asio::experimental::coro&lt;void, void, Executor, Allocator&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> RPCHandler, <span class="keyword">class</span> CompletionHandler&gt;</div>
<div class="line">    <span class="keyword">static</span> boost::asio::deferred_t completion_token(RPCHandler&amp;, CompletionHandler&amp;)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> RPCHandler, <span class="keyword">class</span> CompletionHandler, <span class="keyword">class</span> IoExecutor, <span class="keyword">class</span> Function&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> co_spawn(<span class="keyword">const</span> IoExecutor&amp; io_executor, RPCHandler&amp;, CompletionHandler&amp; completion_handler,</div>
<div class="line">                         Function&amp;&amp; function)</div>
<div class="line">    {</div>
<div class="line">        boost::asio::experimental::co_spawn(</div>
<div class="line">            <span class="keyword">static_cast&lt;</span>Function&amp;&amp;<span class="keyword">&gt;</span>(function)(boost::asio::get_associated_executor(completion_handler, io_executor)),</div>
<div class="line">            boost::asio::detached);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>The executor used to handle each rpc </td></tr>
    <tr><td class="paramname">service</td><td>The service associated with the gRPC method of the <a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a> </td></tr>
    <tr><td class="paramname">rpc_handler</td><td>A callable that produces a coroutine. The coroutine's return value is ignored. </td></tr>
    <tr><td class="paramname">token</td><td>A completion token for signature <span class="tt">void(std::exception_ptr)</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>3.3.0 </dd></dl>

</div>
</div>
<a id="a0fbe3a13a97f8f4de19a290ffaee43cb" name="a0fbe3a13a97f8f4de19a290ffaee43cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbe3a13a97f8f4de19a290ffaee43cb">&#9670;&#160;</a></span>register_coroutine_rpc_handler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class CoroutineTraits, class RPCHandler, class CompletionToken&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::register_coroutine_rpc_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grpc_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>service</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RPCHandler &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rpc_handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(experimental) Register an coroutine rpc handler for the given method (<a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> overload) </p>
<dl class="section since"><dt>Since</dt><dd>3.3.0 </dd></dl>

</div>
</div>
<a id="a595fc0d5c217d3d94d6d1dd230c09c39" name="a595fc0d5c217d3d94d6d1dd230c09c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595fc0d5c217d3d94d6d1dd230c09c39">&#9670;&#160;</a></span>register_sender_rpc_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class RPCHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::RPCHandlerSender&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, RPCHandler &gt; agrpc::register_sender_rpc_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grpc_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>service</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RPCHandler</td>          <td class="paramname"><span class="paramname"><em>rpc_handler</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a sender rpc handler for the given method. </p>
<p>The rpc handler will be invoked for every incoming request of this gRPC method. It must take <span class="tt"><a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a>&amp;</span> as first argument and <span class="tt">ServerRPC::Request&amp;</span> as second argument (only for unary and server-streaming rpcs). The <a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a> is automatically cancelled at the end of the rpc handler's sender if <span class="tt">finish()</span> was not called earlier.</p>
<p>This asynchronous operation runs forever unless it is cancelled, the rpc handler throws an exception or the server is shutdown (<a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_server_interface.html#a6a1d337270116c95f387e0abf01f6c6c">grpc::Server::Shutdown</a> is called). At which point it invokes the receiver (passing forward the exception thrown by the request handler, if any) after all sender produced by invoking the rpc handler complete.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> server_rpc_unary_sender(<a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a>&amp; grpc_context, example::v1::Example::AsyncService&amp; service)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>RPC = <a class="code hl_class" href="classagrpc_1_1_server_r_p_c.html">agrpc::ServerRPC&lt;&amp;example::v1::Example::AsyncService::RequestUnary&gt;</a>;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="#a595fc0d5c217d3d94d6d1dd230c09c39">agrpc::register_sender_rpc_handler&lt;RPC&gt;</a>(grpc_context, service,</div>
<div class="line">                                                   [](RPC&amp; rpc, RPC::Request&amp; request)</div>
<div class="line">                                                   {</div>
<div class="line">                                                       <span class="keywordflow">return</span> unifex::let_value_with(</div>
<div class="line">                                                           []</div>
<div class="line">                                                           {</div>
<div class="line">                                                               <span class="keywordflow">return</span> RPC::Response{};</div>
<div class="line">                                                           },</div>
<div class="line">                                                           [&amp;](<span class="keyword">auto</span>&amp; response)</div>
<div class="line">                                                           {</div>
<div class="line">                                                               response.set_integer(request.integer());</div>
<div class="line">                                                               <span class="keywordflow">return</span> rpc.finish(response, grpc::Status::OK);</div>
<div class="line">                                                           });</div>
<div class="line">                                                   });</div>
<div class="line">}</div>
</div><!-- fragment --><p>[(experimental) Additionally, the rpc handler may have a method called <span class="tt">request_message_factory()</span>. If it does then that method will be invoked and the returned object used to create and destroy the initial request message for unary and server-streaming rpcs.</p>
<p>Example: (since 3.4.0)]</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ArenaRequestMessageFactory</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Request&gt;</div>
<div class="line">    Request&amp; create()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> *google::protobuf::Arena::Create&lt;Request&gt;(&amp;arena_);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This method is optional and can be omitted</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Request&gt;</div>
<div class="line">    <span class="keywordtype">void</span> destroy(Request&amp;) <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    google::protobuf::Arena arena_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Handler&gt;</div>
<div class="line"><span class="keyword">class </span>RPCHandlerWithArenaRequestMessageFactory</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> RPCHandlerWithArenaRequestMessageFactory(Handler handler) : handler_(std::move(handler)) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) operator()(Args&amp;&amp;... args)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// for unary and server-streaming rpcs args are: ServerRPC&amp;, Request&amp;,</span></div>
<div class="line">        <span class="comment">// ArenaRequestMessageFactory&amp;</span></div>
<div class="line">        <span class="keywordflow">return</span> handler_(std::forward&lt;Args&gt;(args)...);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ArenaRequestMessageFactory request_message_factory() { <span class="keywordflow">return</span> {}; }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    Handler handler_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ServerRPC, <span class="keyword">class</span> RPCHandler&gt;</div>
<div class="line"><span class="keywordtype">void</span> register_rpc_handler(<a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a>&amp; grpc_context, example::v1::Example::AsyncService&amp; service,</div>
<div class="line">                          RPCHandler&amp;&amp; handler)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="#ae09f3bd4a00ce92682d30395d1fba52f">agrpc::register_awaitable_rpc_handler&lt;ServerRPC&gt;</a>(</div>
<div class="line">        grpc_context, service, RPCHandlerWithArenaRequestMessageFactory{std::forward&lt;RPCHandler&gt;(handler)},</div>
<div class="line">        asio::detached);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a></td><td>An instantiation of <span class="tt"><a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">agrpc::ServerRPC</a></span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grpc_context</td><td>The <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> used to handle each rpc </td></tr>
    <tr><td class="paramname">service</td><td>The service associated with the gRPC method of the <a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a> </td></tr>
    <tr><td class="paramname">rpc_handler</td><td>A callable that produces a sender</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.7.0 </dd></dl>

</div>
</div>
<a id="ac51d4bae04909dc6624b34e8931f4a6f" name="ac51d4bae04909dc6624b34e8931f4a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51d4bae04909dc6624b34e8931f4a6f">&#9670;&#160;</a></span>register_yield_rpc_handler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class RPCHandler, class CompletionToken = detail::DefaultCompletionTokenT&lt;typename ServerRPC::executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::register_yield_rpc_handler </td>
          <td>(</td>
          <td class="paramtype">const typename ServerRPC::executor_type &amp;</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>service</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RPCHandler</td>          <td class="paramname"><span class="paramname"><em>rpc_handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a Boost.Coroutine rpc handler for the given method. </p>
<p>The rpc handler will be invoked for every incoming request of this gRPC method. It must take <span class="tt"><a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a>&amp;</span> as first, <span class="tt">ServerRPC::Request&amp;</span> as second (only for unary and server-streaming rpcs) and <span class="tt">asio::basic_yield_context&lt;Executor&gt;</span> as third argument. The Executor is obtained by calling <span class="tt">asio::get_associated_executor(completion_handler, executor)</span>, where <span class="tt">completion_handler</span> is created from <span class="tt">token</span> and <span class="tt">executor</span> the first argument passed to this function. The <a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a> is automatically cancelled at the end of the rpc handler if <span class="tt">finish()</span> was not called earlier.</p>
<p>This asynchronous operation runs forever unless it is cancelled, the rpc handler throws an exception or the server is shutdown (<a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_server_interface.html#a6a1d337270116c95f387e0abf01f6c6c">grpc::Server::Shutdown</a> is called). At which point it invokes the completion handler (passing forward the exception thrown by the request handler, if any) after all invocations of the rpc handler return.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> server_rpc_unary_yield(<a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a>&amp; grpc_context, example::v1::Example::AsyncService&amp; service)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>RPC = <a class="code hl_class" href="classagrpc_1_1_server_r_p_c.html">agrpc::ServerRPC&lt;&amp;example::v1::Example::AsyncService::RequestUnary&gt;</a>;</div>
<div class="line">    <a class="code hl_function" href="#ac51d4bae04909dc6624b34e8931f4a6f">agrpc::register_yield_rpc_handler&lt;RPC&gt;</a>(</div>
<div class="line">        grpc_context, service,</div>
<div class="line">        [](RPC&amp; rpc, RPC::Request&amp; request, <span class="keyword">const</span> asio::yield_context&amp; yield)</div>
<div class="line">        {</div>
<div class="line">            RPC::Response response;</div>
<div class="line">            response.set_integer(request.integer());</div>
<div class="line">            rpc.finish(response, grpc::Status::OK, yield);</div>
<div class="line">        },</div>
<div class="line">        asio::detached);</div>
<div class="line">}</div>
</div><!-- fragment --><p>[(experimental) Additionally, the rpc handler may have a method called <span class="tt">request_message_factory()</span>. If it does then that method will be invoked and the returned object used to create and destroy the initial request message for unary and server-streaming rpcs.</p>
<p>Example: (since 3.4.0)]</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ArenaRequestMessageFactory</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Request&gt;</div>
<div class="line">    Request&amp; create()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> *google::protobuf::Arena::Create&lt;Request&gt;(&amp;arena_);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This method is optional and can be omitted</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Request&gt;</div>
<div class="line">    <span class="keywordtype">void</span> destroy(Request&amp;) <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    google::protobuf::Arena arena_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Handler&gt;</div>
<div class="line"><span class="keyword">class </span>RPCHandlerWithArenaRequestMessageFactory</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> RPCHandlerWithArenaRequestMessageFactory(Handler handler) : handler_(std::move(handler)) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) operator()(Args&amp;&amp;... args)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// for unary and server-streaming rpcs args are: ServerRPC&amp;, Request&amp;,</span></div>
<div class="line">        <span class="comment">// ArenaRequestMessageFactory&amp;</span></div>
<div class="line">        <span class="keywordflow">return</span> handler_(std::forward&lt;Args&gt;(args)...);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ArenaRequestMessageFactory request_message_factory() { <span class="keywordflow">return</span> {}; }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    Handler handler_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ServerRPC, <span class="keyword">class</span> RPCHandler&gt;</div>
<div class="line"><span class="keywordtype">void</span> register_rpc_handler(<a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a>&amp; grpc_context, example::v1::Example::AsyncService&amp; service,</div>
<div class="line">                          RPCHandler&amp;&amp; handler)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="#ae09f3bd4a00ce92682d30395d1fba52f">agrpc::register_awaitable_rpc_handler&lt;ServerRPC&gt;</a>(</div>
<div class="line">        grpc_context, service, RPCHandlerWithArenaRequestMessageFactory{std::forward&lt;RPCHandler&gt;(handler)},</div>
<div class="line">        asio::detached);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a></td><td>An instantiation of <span class="tt"><a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">agrpc::ServerRPC</a></span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>The executor used to handle each rpc </td></tr>
    <tr><td class="paramname">service</td><td>The service associated with the gRPC method of the <a class="el" href="classagrpc_1_1_server_r_p_c.html" title="Primary ServerRPC template.">ServerRPC</a> </td></tr>
    <tr><td class="paramname">rpc_handler</td><td>A callable that takes an <span class="tt">asio::basic_yield_context&lt;Executor&gt;</span> as last argument. The return value is ignored. The Executor must be constructible from <span class="tt">asio::get_associated_executor(completion_handler,
executor)</span>, where <span class="tt">completion_handler</span> is obtained from <span class="tt">token</span> and <span class="tt">executor</span> the first argument passed to this function. </td></tr>
    <tr><td class="paramname">token</td><td>A completion token for signature <span class="tt">void(std::exception_ptr)</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.7.0 </dd></dl>

</div>
</div>
<a id="ac296ea567f88e9ccd85642736dcba97a" name="ac296ea567f88e9ccd85642736dcba97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac296ea567f88e9ccd85642736dcba97a">&#9670;&#160;</a></span>register_yield_rpc_handler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a>, class RPCHandler, class CompletionToken&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::register_yield_rpc_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grpc_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::ServerRPCServiceT&lt; <a class="el" href="classagrpc_1_1_server_r_p_c.html">ServerRPC</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>service</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RPCHandler &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rpc_handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a rpc handler for the given method (<a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> overload) </p>
<dl class="section since"><dt>Since</dt><dd>2.7.0 </dd></dl>

</div>
</div>
<a id="ab52a5b6f6ce90d1bc9faa5baa96a39fa" name="ab52a5b6f6ce90d1bc9faa5baa96a39fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52a5b6f6ce90d1bc9faa5baa96a39fa">&#9670;&#160;</a></span>run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits = agrpc::DefaultRunTraits, class ExecutionContext = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void agrpc::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grpc_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>execution_context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(experimental) Run an execution context in the same thread as a <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> </p>
<p>The <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> should be in the ready state when this function is invoked, other than that semantically identical to <a class="el" href="classagrpc_1_1_grpc_context.html#acb1dae170b054aba4c83e266c456fee0" title="Run ready completion handlers and grpc::CompletionQueue">GrpcContext::run()</a>. This function ends when the <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> is stopped, e.g. because it ran out of work.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>See <a class="el" href="structagrpc_1_1_default_run_traits.html" title="(experimental) Default run traits">DefaultRunTraits</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.7.0 </dd></dl>

</div>
</div>
<a id="a075e15728ee3eac5531f3202cfaf6c38" name="a075e15728ee3eac5531f3202cfaf6c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075e15728ee3eac5531f3202cfaf6c38">&#9670;&#160;</a></span>run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits = agrpc::DefaultRunTraits, class ExecutionContext = void, class StopCondition = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void agrpc::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grpc_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>execution_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StopCondition</td>          <td class="paramname"><span class="paramname"><em>stop_condition</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(experimental) Run an execution context in the same thread as a <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> </p>
<p>The <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> should be in the ready state when this function is invoked, other than that semantically identical to <a class="el" href="classagrpc_1_1_grpc_context.html#acb1dae170b054aba4c83e266c456fee0" title="Run ready completion handlers and grpc::CompletionQueue">GrpcContext::run()</a>. This function ends when the <span class="tt">stop_condition</span> returns <span class="tt">true</span>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>See <a class="el" href="structagrpc_1_1_default_run_traits.html" title="(experimental) Default run traits">DefaultRunTraits</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.7.0 </dd></dl>

</div>
</div>
<a id="a7c08e9c2d581c89024ba71489fc5aaf3" name="a7c08e9c2d581c89024ba71489fc5aaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c08e9c2d581c89024ba71489fc5aaf3">&#9670;&#160;</a></span>run_completion_queue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits = agrpc::DefaultRunTraits, class ExecutionContext = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void agrpc::run_completion_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grpc_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>execution_context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(experimental) Run an execution context in the same thread as a <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a>'s completion queue </p>
<p>The <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> should be in the ready state when this function is invoked, other than that semantically identical to <a class="el" href="classagrpc_1_1_grpc_context.html#a627dcc6bc3401d204d976b6fea6e00a3" title="Run the grpc::CompletionQueue">GrpcContext::run_completion_queue()</a>. This function ends when the <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> is stopped, e.g. because it ran out of work.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>See <a class="el" href="structagrpc_1_1_default_run_traits.html" title="(experimental) Default run traits">DefaultRunTraits</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.0.0 </dd></dl>

</div>
</div>
<a id="a32f6562885c161c318d08f83e48468e8" name="a32f6562885c161c318d08f83e48468e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f6562885c161c318d08f83e48468e8">&#9670;&#160;</a></span>run_completion_queue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits = agrpc::DefaultRunTraits, class ExecutionContext = void, class StopCondition = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void agrpc::run_completion_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grpc_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>execution_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StopCondition</td>          <td class="paramname"><span class="paramname"><em>stop_condition</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(experimental) Run an execution context in the same thread as a <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a>'s completion queue </p>
<p>The <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a> should be in the ready state when this function is invoked, other than that semantically identical to <a class="el" href="classagrpc_1_1_grpc_context.html#a627dcc6bc3401d204d976b6fea6e00a3" title="Run the grpc::CompletionQueue">GrpcContext::run_completion_queue()</a>. This function ends when the <span class="tt">stop_condition</span> returns <span class="tt">true</span>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>See <a class="el" href="structagrpc_1_1_default_run_traits.html" title="(experimental) Default run traits">DefaultRunTraits</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.0.0 </dd></dl>

</div>
</div>
<a id="accc81e3886098f4472dbe3e528594e3e" name="accc81e3886098f4472dbe3e528594e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc81e3886098f4472dbe3e528594e3e">&#9670;&#160;</a></span>process_grpc_tag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void agrpc::process_grpc_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grpc_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ok</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test utility to manually process gRPC tags. </p>
<p>This function can be used to process gRPC tags in places where the tag does not go through the <span class="tt">grpc::CompletionQueue</span>, for example in mocked stubs. It processes the tag in a manner equivalent to <span class="tt">asio::post</span> while being compatible with <span class="tt"><a class="el" href="classagrpc_1_1_grpc_context.html#a627dcc6bc3401d204d976b6fea6e00a3" title="Run the grpc::CompletionQueue">GrpcContext::run_completion_queue()</a></span>/<span class="tt"><a class="el" href="classagrpc_1_1_grpc_context.html#af35c5d430df1d778320a2fe51ec40102" title="Poll the grpc::CompletionQueue">GrpcContext::poll_completion_queue()</a></span>.</p>
<p>Example using Google Mock:</p>
<div class="fragment"><div class="line">    <span class="comment">// Setup mock stub</span></div>
<div class="line">    <span class="keyword">struct </span>MockResponseReader : grpc::ClientAsyncResponseReaderInterface&lt;example::v1::Response&gt;</div>
<div class="line">    {</div>
<div class="line">        MOCK_METHOD0(StartCall, <span class="keywordtype">void</span>());</div>
<div class="line">        MOCK_METHOD1(ReadInitialMetadata, <span class="keywordtype">void</span>(<span class="keywordtype">void</span>*));</div>
<div class="line">        MOCK_METHOD3(Finish, <span class="keywordtype">void</span>(example::v1::Response*, grpc::Status*, <span class="keywordtype">void</span>*));</div>
<div class="line">    };</div>
<div class="line">    testing::NiceMock&lt;example::v1::MockExampleStub&gt; mock_stub;</div>
<div class="line">    testing::NiceMock&lt;MockResponseReader&gt; mock_reader;</div>
<div class="line">    EXPECT_CALL(mock_reader, Finish)</div>
<div class="line">        .WillOnce(</div>
<div class="line">            [&amp;](example::v1::Response* response, grpc::Status* status, <span class="keywordtype">void</span>* tag)</div>
<div class="line">            {</div>
<div class="line">                *status = grpc::Status::OK;</div>
<div class="line">                response-&gt;set_integer(42);</div>
<div class="line">                <a class="code hl_function" href="#accc81e3886098f4472dbe3e528594e3e">agrpc::process_grpc_tag</a>(grpc_context, tag, <span class="keyword">true</span>);</div>
<div class="line">            });</div>
<div class="line">    EXPECT_CALL(mock_stub, AsyncUnaryRaw).WillOnce(testing::Return(&amp;mock_reader));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Inject mock_stub into code under test</span></div>
<div class="line">    <span class="keyword">using </span>RPC = <a class="code hl_class" href="classagrpc_1_1_client_r_p_c.html">agrpc::ClientRPC&lt;&amp;example::v1::Example::StubInterface::AsyncUnary&gt;</a>;</div>
<div class="line">    grpc::ClientContext client_context;</div>
<div class="line">    example::v1::Response response;</div>
<div class="line">    example::v1::Request request;</div>
<div class="line">    <span class="keyword">const</span> grpc::Status status =</div>
<div class="line">        <span class="keyword">co_await</span> RPC::request(grpc_context, mock_stub, client_context, request, response, asio::use_awaitable);</div>
<div class="line"> </div>
<div class="line">    EXPECT_TRUE(status.ok());</div>
<div class="line">    EXPECT_EQ(42, response.integer());</div>
</div><!-- fragment --><dl class="section since"><dt>Since</dt><dd>1.7.0 </dd></dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a3f3ac92b1e47fe65b8bbef1b3af97c60" name="a3f3ac92b1e47fe65b8bbef1b3af97c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3ac92b1e47fe65b8bbef1b3af97c60">&#9670;&#160;</a></span>notify_on_state_change</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structagrpc_1_1detail_1_1_notify_on_state_change_fn.html">detail::NotifyOnStateChangeFn</a> agrpc::notify_on_state_change {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set notification for a <span class="tt">grpc::Channel</span> state change. </p>
<p><a class="el" href="structagrpc_1_1detail_1_1_notify_on_state_change_fn.html">Function to set notification for a <span class="tt">grpc::Channel</span> state change. </a></p>
<dl class="section since"><dt>Since</dt><dd>2.3.0 </dd></dl>

</div>
</div>
<a id="a685510388ab87c9a90c44f880e9de9cd" name="a685510388ab87c9a90c44f880e9de9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685510388ab87c9a90c44f880e9de9cd">&#9670;&#160;</a></span>read</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structagrpc_1_1detail_1_1_read_fn.html">detail::ReadFn</a> agrpc::read {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from a streaming RPC. </p>
<p><a class="el" href="structagrpc_1_1detail_1_1_read_fn.html">Client and server-side function to read from streaming RPCs. </a> </p>

</div>
</div>
<a id="aa9c38be6a3d7d59a78007bc4fff311a4" name="aa9c38be6a3d7d59a78007bc4fff311a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c38be6a3d7d59a78007bc4fff311a4">&#9670;&#160;</a></span>use_sender</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structagrpc_1_1_use_sender.html">agrpc::UseSender</a> agrpc::use_sender {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instance and factory for sender completion tokens. </p>
<p><a class="el" href="structagrpc_1_1_use_sender.html">Sender completion token. </a> </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceagrpc.html">agrpc</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
