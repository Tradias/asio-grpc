<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asio-grpc: agrpc::BasicClientBidiReactor&lt; Request, Response, Executor &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">asio-grpc<span id="projectnumber">&#160;v3.6.0</span>
   </div>
   <div id="projectbrief">Asynchronous gRPC with Asio/unified executors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classagrpc_1_1_basic_client_bidi_reactor.html','','classagrpc_1_1_basic_client_bidi_reactor-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">agrpc::BasicClientBidiReactor&lt; Request, Response, Executor &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>(experimental) I/O object for client-side, bidi-streaming rpcs  
 <a href="#details">More...</a></p>

<p><code>#include &lt;agrpc/client_callback.hpp&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Inheritance diagram for agrpc::BasicClientBidiReactor&lt; Request, Response, Executor &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classagrpc_1_1_basic_client_bidi_reactor__inherit__graph.png" border="0" usemap="#aagrpc_1_1_basic_client_bidi_reactor_3_01_request_00_01_response_00_01_executor_01_4_inherit__map" loading="lazy" alt="Inheritance graph"/></div>
<map name="aagrpc_1_1_basic_client_bidi_reactor_3_01_request_00_01_response_00_01_executor_01_4_inherit__map" id="aagrpc_1_1_basic_client_bidi_reactor_3_01_request_00_01_response_00_01_executor_01_4_inherit__map">
<area shape="rect" title="(experimental) I/O object for client&#45;side, bidi&#45;streaming rpcs" alt="" coords="5,93,245,133"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_reactor_executor_base.html" title="Reactor&#39;s executor base." alt="" coords="17,5,234,45"/>
<area shape="poly" title=" " alt="" coords="128,59,128,93,123,93,123,59"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Collaboration diagram for agrpc::BasicClientBidiReactor&lt; Request, Response, Executor &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classagrpc_1_1_basic_client_bidi_reactor__coll__graph.png" border="0" usemap="#aagrpc_1_1_basic_client_bidi_reactor_3_01_request_00_01_response_00_01_executor_01_4_coll__map" loading="lazy" alt="Collaboration graph"/></div>
<map name="aagrpc_1_1_basic_client_bidi_reactor_3_01_request_00_01_response_00_01_executor_01_4_coll__map" id="aagrpc_1_1_basic_client_bidi_reactor_3_01_request_00_01_response_00_01_executor_01_4_coll__map">
<area shape="rect" title="(experimental) I/O object for client&#45;side, bidi&#45;streaming rpcs" alt="" coords="5,93,245,133"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_reactor_executor_base.html" title="Reactor&#39;s executor base." alt="" coords="17,5,234,45"/>
<area shape="poly" title=" " alt="" coords="128,59,128,93,123,93,123,59"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:rebind_5Fexecutor" id="r_rebind_5Fexecutor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structagrpc_1_1_basic_client_bidi_reactor_1_1rebind__executor.html">rebind_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind the <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html" title="(experimental) I/O object for client-side, bidi-streaming rpcs">BasicClientBidiReactor</a> to another executor.  <a href="structagrpc_1_1_basic_client_bidi_reactor_1_1rebind__executor.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac75fc4f9baf950aaf3e2281fc83846d0" id="r_ac75fc4f9baf950aaf3e2281fc83846d0"><td class="memItemLeft" align="right" valign="top"><a id="ac75fc4f9baf950aaf3e2281fc83846d0" name="ac75fc4f9baf950aaf3e2281fc83846d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>executor_type</b> = Executor</td></tr>
<tr class="memdesc:ac75fc4f9baf950aaf3e2281fc83846d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The executor type. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a29dd0910d34dfd08ef7b90621a7bba59" id="r_a29dd0910d34dfd08ef7b90621a7bba59"><td class="memTemplParams" colspan="2">template&lt;class StubAsync&gt; </td></tr>
<tr class="memitem:a29dd0910d34dfd08ef7b90621a7bba59 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29dd0910d34dfd08ef7b90621a7bba59">start</a> (detail::AsyncBidiStreamingReactorFn&lt; StubAsync, Request, Response &gt; fn, StubAsync *stub)</td></tr>
<tr class="memdesc:a29dd0910d34dfd08ef7b90621a7bba59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a codegen-ed rpc.  <br /></td></tr>
<tr class="memitem:a0fc3e0d749f2616e7e76f1e81b05d865" id="r_a0fc3e0d749f2616e7e76f1e81b05d865"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a0fc3e0d749f2616e7e76f1e81b05d865 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fc3e0d749f2616e7e76f1e81b05d865">wait_for_initial_metadata</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a0fc3e0d749f2616e7e76f1e81b05d865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for initial metadata.  <br /></td></tr>
<tr class="memitem:af114aded7cf3cdf1148b69b26b162bd3" id="r_af114aded7cf3cdf1148b69b26b162bd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af114aded7cf3cdf1148b69b26b162bd3">initiate_read</a> (Response &amp;response)</td></tr>
<tr class="memdesc:af114aded7cf3cdf1148b69b26b162bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read message.  <br /></td></tr>
<tr class="memitem:a3c2f78a98957eb28579833fea0ecdeea" id="r_a3c2f78a98957eb28579833fea0ecdeea"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a3c2f78a98957eb28579833fea0ecdeea template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c2f78a98957eb28579833fea0ecdeea">wait_for_read</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a3c2f78a98957eb28579833fea0ecdeea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for write.  <br /></td></tr>
<tr class="memitem:a77205132d783e3404c669b53cb015017" id="r_a77205132d783e3404c669b53cb015017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77205132d783e3404c669b53cb015017">initiate_write</a> (const Request &amp;request, grpc::WriteOptions options={})</td></tr>
<tr class="memdesc:a77205132d783e3404c669b53cb015017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write message.  <br /></td></tr>
<tr class="memitem:a9a158c126bc3900607f9cc339d3a55a4" id="r_a9a158c126bc3900607f9cc339d3a55a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a158c126bc3900607f9cc339d3a55a4">initiate_writes_done</a> ()</td></tr>
<tr class="memdesc:a9a158c126bc3900607f9cc339d3a55a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the rpc will have no more write operations.  <br /></td></tr>
<tr class="memitem:a542fb606332cde590ecde8da03c67368" id="r_a542fb606332cde590ecde8da03c67368"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a542fb606332cde590ecde8da03c67368 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a542fb606332cde590ecde8da03c67368">wait_for_write</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a542fb606332cde590ecde8da03c67368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for write.  <br /></td></tr>
<tr class="memitem:aa340dddd6b7f1dabb6e573782e64a629" id="r_aa340dddd6b7f1dabb6e573782e64a629"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:aa340dddd6b7f1dabb6e573782e64a629 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa340dddd6b7f1dabb6e573782e64a629">wait_for_writes_done</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:aa340dddd6b7f1dabb6e573782e64a629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for writes done.  <br /></td></tr>
<tr class="memitem:a23e2cb94553c144adaa13ed21852ab95" id="r_a23e2cb94553c144adaa13ed21852ab95"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a23e2cb94553c144adaa13ed21852ab95 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23e2cb94553c144adaa13ed21852ab95">wait_for_finish</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a23e2cb94553c144adaa13ed21852ab95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for finish.  <br /></td></tr>
<tr class="memitem:ac5c445971590ac7faa30a097acdca064" id="r_ac5c445971590ac7faa30a097acdca064"><td class="memItemLeft" align="right" valign="top">const Executor &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_reactor_executor_base.html#ac5c445971590ac7faa30a097acdca064">get_executor</a> () const noexcept</td></tr>
<tr class="memdesc:ac5c445971590ac7faa30a097acdca064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the executor.  <br /></td></tr>
<tr class="memitem:a08b8983aa09b885d9f89abc7f2b9b2fc" id="r_a08b8983aa09b885d9f89abc7f2b9b2fc"><td class="memItemLeft" align="right" valign="top"><a id="a08b8983aa09b885d9f89abc7f2b9b2fc" name="a08b8983aa09b885d9f89abc7f2b9b2fc"></a>
grpc::ClientContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>context</b> () noexcept</td></tr>
<tr class="memdesc:a08b8983aa09b885d9f89abc7f2b9b2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying <span class="tt">grpc::ClientContext</span> <br /></td></tr>
<tr class="memitem:a712e4f2d3aae3394fe4c3db5f88d88ac" id="r_a712e4f2d3aae3394fe4c3db5f88d88ac"><td class="memItemLeft" align="right" valign="top"><a id="a712e4f2d3aae3394fe4c3db5f88d88ac" name="a712e4f2d3aae3394fe4c3db5f88d88ac"></a>
const grpc::ClientContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>context</b> () const noexcept</td></tr>
<tr class="memdesc:a712e4f2d3aae3394fe4c3db5f88d88ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying <span class="tt">grpc::ClientContext</span> (const overload) <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Request, class Response, class Executor&gt;<br />
class agrpc::BasicClientBidiReactor&lt; Request, Response, Executor &gt;</div><p>(experimental) I/O object for client-side, bidi-streaming rpcs </p>
<p>Create an object of this type using <span class="tt"><a class="el" href="namespaceagrpc.html#a59ca62564b50007b111375aa090e752b" title="Create ReactorPtr.">agrpc::make_reactor</a></span>/<span class="tt"><a class="el" href="namespaceagrpc.html#a0704072818e6d125ef22b0ae1bbe324e" title="Create ReactorPtr using allocator.">agrpc::allocate_reactor</a></span>.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> bidi_streaming(asio::io_context&amp; io_context, example::v1::Example::Stub&amp; stub)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> ptr = <a class="code hl_function" href="namespaceagrpc.html#a59ca62564b50007b111375aa090e752b">agrpc::make_reactor&lt;agrpc::ClientBidiReactor&lt;example::v1::Request, example::v1::Response&gt;</a>&gt;(</div>
<div class="line">        io_context.get_executor());</div>
<div class="line">    <span class="keyword">auto</span>&amp; rpc = *ptr;</div>
<div class="line">    rpc.start(&amp;example::v1::Example::Stub::async::BidirectionalStreaming, stub.async());</div>
<div class="line">    <span class="keyword">auto</span> request = std::make_unique&lt;example::v1::Request&gt;();</div>
<div class="line">    rpc.initiate_write(*request);</div>
<div class="line">    rpc.wait_for_write(</div>
<div class="line">        [ptr = std::move(ptr), request = std::move(request)](<span class="keyword">const</span> error_code&amp;, <span class="keywordtype">bool</span> ok) <span class="keyword">mutable</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (!ok)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keyword">auto</span>&amp; rpc = *ptr;</div>
<div class="line">            <span class="keyword">auto</span> response = std::make_unique&lt;example::v1::Response&gt;();</div>
<div class="line">            rpc.initiate_read(*response);</div>
<div class="line">            rpc.wait_for_read(</div>
<div class="line">                [ptr = std::move(ptr), response = std::move(response)](<span class="keyword">const</span> error_code&amp;, <span class="keywordtype">bool</span> ok)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">if</span> (!ok)</div>
<div class="line">                    {</div>
<div class="line">                        <span class="keywordflow">return</span>;</div>
<div class="line">                    }</div>
<div class="line">                    ptr-&gt;wait_for_finish(</div>
<div class="line">                        [](<span class="keyword">const</span> error_code&amp;, <span class="keyword">const</span> grpc::Status&amp; status)</div>
<div class="line">                        {</div>
<div class="line">                            <span class="keywordflow">if</span> (!status.ok())</div>
<div class="line">                            {</div>
<div class="line">                                <span class="comment">// ...</span></div>
<div class="line">                            }</div>
<div class="line">                        });</div>
<div class="line">                });</div>
<div class="line">        });</div>
<div class="line">}</div>
</div><!-- fragment --><p>Based on <span class="tt">.proto</span> file:</p>
<div class="fragment"><div class="line">syntax = &quot;proto3&quot;;</div>
<div class="line"> </div>
<div class="line">package example.v1;</div>
<div class="line"> </div>
<div class="line">service Example {</div>
<div class="line">  rpc ServerStreaming(Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc ClientStreaming(stream Request) returns (Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc BidirectionalStreaming(stream Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc Unary(Request) returns (Response) {}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Request {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Response {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Executor</td><td>The executor type.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Per-Operation Cancellation</b></p>
<p>All. Cancellation will merely interrupt the act of waiting and does not cancel the underlying rpc.</p>
<dl class="section since"><dt>Since</dt><dd>3.5.0 </dd></dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a29dd0910d34dfd08ef7b90621a7bba59" name="a29dd0910d34dfd08ef7b90621a7bba59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29dd0910d34dfd08ef7b90621a7bba59">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request, class Response, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class StubAsync&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::start </td>
          <td>(</td>
          <td class="paramtype">detail::AsyncBidiStreamingReactorFn&lt; StubAsync, Request, Response &gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StubAsync *</td>          <td class="paramname"><span class="paramname"><em>stub</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a codegen-ed rpc. </p>
<p>The response object must remain valid until the rpc is finished. May only be called once.</p>
<ul>
<li>fn Pointer to the protoc generated <span class="tt">Stub::async::Method</span>. </li>
</ul>

</div>
</div>
<a id="a0fc3e0d749f2616e7e76f1e81b05d865" name="a0fc3e0d749f2616e7e76f1e81b05d865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc3e0d749f2616e7e76f1e81b05d865">&#9670;&#160;</a></span>wait_for_initial_metadata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request, class Response, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::wait_for_initial_metadata </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for initial metadata. </p>
<p>Only one wait for initial metadata may be outstanding at any time.</p>
<p>Completion signature is <span class="tt">void(error_code, bool)</span>. If the bool is <span class="tt">false</span> then the rpc failed (cancelled, disconnected, deadline reached, ...). </p>

</div>
</div>
<a id="af114aded7cf3cdf1148b69b26b162bd3" name="af114aded7cf3cdf1148b69b26b162bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af114aded7cf3cdf1148b69b26b162bd3">&#9670;&#160;</a></span>initiate_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request, class Response, class Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::initiate_read </td>
          <td>(</td>
          <td class="paramtype">Response &amp;</td>          <td class="paramname"><span class="paramname"><em>response</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read message. </p>
<p>Initiate the read of a message. The argument must remain valid until the write completes (<span class="tt">wait_for_read</span>). </p>

</div>
</div>
<a id="a3c2f78a98957eb28579833fea0ecdeea" name="a3c2f78a98957eb28579833fea0ecdeea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2f78a98957eb28579833fea0ecdeea">&#9670;&#160;</a></span>wait_for_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request, class Response, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::wait_for_read </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for write. </p>
<p>Waits for the completion of a read. Only one wait for write may be outstanding at any time.</p>
<p>Completion signature is <span class="tt">void(error_code, bool)</span>. If the bool is <span class="tt">false</span> then the rpc failed (cancelled, disconnected, deadline reached, ...). </p>

</div>
</div>
<a id="a77205132d783e3404c669b53cb015017" name="a77205132d783e3404c669b53cb015017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77205132d783e3404c669b53cb015017">&#9670;&#160;</a></span>initiate_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request, class Response, class Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::initiate_write </td>
          <td>(</td>
          <td class="paramtype">const Request &amp;</td>          <td class="paramname"><span class="paramname"><em>request</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">grpc::WriteOptions</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write message. </p>
<p>Initiate the write of a message. The argument must remain valid until the write completes (<span class="tt">wait_for_write</span>). If <span class="tt">WriteOptions::set_last_message()</span> is present then no more calls to <span class="tt">initiate_write</span> or <span class="tt">initiate_writes_done</span> are allowed. </p>

</div>
</div>
<a id="a9a158c126bc3900607f9cc339d3a55a4" name="a9a158c126bc3900607f9cc339d3a55a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a158c126bc3900607f9cc339d3a55a4">&#9670;&#160;</a></span>initiate_writes_done()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request, class Response, class Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::initiate_writes_done </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicate that the rpc will have no more write operations. </p>
<p>This can only be issued once for a given rpc. This is not required or allowed if <span class="tt">initiate_write</span> with <span class="tt">set_last_message()</span> is used since that already has the same implication. Note that calling this means that no more calls to <span class="tt">initiate_write</span> or <span class="tt">initiate_writes_done</span> are allowed. </p>

</div>
</div>
<a id="a542fb606332cde590ecde8da03c67368" name="a542fb606332cde590ecde8da03c67368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542fb606332cde590ecde8da03c67368">&#9670;&#160;</a></span>wait_for_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request, class Response, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::wait_for_write </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for write. </p>
<p>Waits for the completion of a write. Only one wait for write may be outstanding at any time.</p>
<p>Completion signature is <span class="tt">void(error_code, bool)</span>. If the bool is <span class="tt">false</span> then the rpc failed (cancelled, disconnected, deadline reached, ...). </p>

</div>
</div>
<a id="aa340dddd6b7f1dabb6e573782e64a629" name="aa340dddd6b7f1dabb6e573782e64a629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa340dddd6b7f1dabb6e573782e64a629">&#9670;&#160;</a></span>wait_for_writes_done()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request, class Response, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::wait_for_writes_done </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for writes done. </p>
<p>Waits for the completion of <span class="tt">writes_done</span>. Only one wait for write may be outstanding at any time.</p>
<p>Completion signature is <span class="tt">void(error_code, bool)</span>. If the bool is <span class="tt">false</span> then the rpc failed (cancelled, disconnected, deadline reached, ...). </p>

</div>
</div>
<a id="a23e2cb94553c144adaa13ed21852ab95" name="a23e2cb94553c144adaa13ed21852ab95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e2cb94553c144adaa13ed21852ab95">&#9670;&#160;</a></span>wait_for_finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request, class Response, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::wait_for_finish </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for finish. </p>
<p>Wait until all operations associated with this rpc have completed. No more reads or writes may be initiated on this rpc after this function has been called. Only one wait for finish may be outstanding at any time.</p>
<p>Completion signature is <span class="tt">void(error_code, grpc::Status)</span>. </p>

</div>
</div>
<a id="ac5c445971590ac7faa30a097acdca064" name="ac5c445971590ac7faa30a097acdca064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c445971590ac7faa30a097acdca064">&#9670;&#160;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Executor &amp; <a class="el" href="classagrpc_1_1detail_1_1_reactor_executor_base.html">agrpc::detail::ReactorExecutorBase</a>&lt; Executor &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the executor. </p>
<p>Thread-safe </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceagrpc.html">agrpc</a></li><li class="navelem"><a href="classagrpc_1_1_basic_client_bidi_reactor.html">BasicClientBidiReactor</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
