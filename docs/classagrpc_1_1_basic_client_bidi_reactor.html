<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asio-grpc: agrpc::BasicClientBidiReactor&lt; Request, Response, Executor &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">asio-grpc<span id="projectnumber">&#160;v3.5.0</span>
   </div>
   <div id="projectbrief">Asynchronous gRPC with Asio/unified executors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classagrpc_1_1_basic_client_bidi_reactor.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classagrpc_1_1_basic_client_bidi_reactor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">agrpc::BasicClientBidiReactor&lt; Request, Response, Executor &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>(experimental) I/O object for client-side, bidi-streaming rpcs  
 <a href="#details">More...</a></p>

<p><code>#include &lt;agrpc/client_callback.hpp&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for agrpc::BasicClientBidiReactor&lt; Request, Response, Executor &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classagrpc_1_1_basic_client_bidi_reactor__inherit__graph.png" border="0" usemap="#aagrpc_1_1_basic_client_bidi_reactor_3_01_request_00_01_response_00_01_executor_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aagrpc_1_1_basic_client_bidi_reactor_3_01_request_00_01_response_00_01_executor_01_4_inherit__map" id="aagrpc_1_1_basic_client_bidi_reactor_3_01_request_00_01_response_00_01_executor_01_4_inherit__map">
<area shape="rect" title="(experimental) I/O object for client&#45;side, bidi&#45;streaming rpcs" alt="" coords="5,93,245,133"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_reactor_executor_base.html" title="Reactor&#39;s executor base." alt="" coords="17,5,234,45"/>
<area shape="poly" title=" " alt="" coords="128,59,128,93,123,93,123,59"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for agrpc::BasicClientBidiReactor&lt; Request, Response, Executor &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classagrpc_1_1_basic_client_bidi_reactor__coll__graph.png" border="0" usemap="#aagrpc_1_1_basic_client_bidi_reactor_3_01_request_00_01_response_00_01_executor_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aagrpc_1_1_basic_client_bidi_reactor_3_01_request_00_01_response_00_01_executor_01_4_coll__map" id="aagrpc_1_1_basic_client_bidi_reactor_3_01_request_00_01_response_00_01_executor_01_4_coll__map">
<area shape="rect" title="(experimental) I/O object for client&#45;side, bidi&#45;streaming rpcs" alt="" coords="5,93,245,133"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_reactor_executor_base.html" title="Reactor&#39;s executor base." alt="" coords="17,5,234,45"/>
<area shape="poly" title=" " alt="" coords="128,59,128,93,123,93,123,59"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structagrpc_1_1_basic_client_bidi_reactor_1_1rebind__executor.html">rebind_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind the <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html" title="(experimental) I/O object for client-side, bidi-streaming rpcs">BasicClientBidiReactor</a> to another executor.  <a href="structagrpc_1_1_basic_client_bidi_reactor_1_1rebind__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac75fc4f9baf950aaf3e2281fc83846d0" id="r_ac75fc4f9baf950aaf3e2281fc83846d0"><td class="memItemLeft" align="right" valign="top"><a id="ac75fc4f9baf950aaf3e2281fc83846d0" name="ac75fc4f9baf950aaf3e2281fc83846d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>executor_type</b> = Executor</td></tr>
<tr class="memdesc:ac75fc4f9baf950aaf3e2281fc83846d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The executor type. <br /></td></tr>
<tr class="separator:ac75fc4f9baf950aaf3e2281fc83846d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a29dd0910d34dfd08ef7b90621a7bba59" id="r_a29dd0910d34dfd08ef7b90621a7bba59"><td class="memTemplParams" colspan="2">template&lt;class StubAsync &gt; </td></tr>
<tr class="memitem:a29dd0910d34dfd08ef7b90621a7bba59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a29dd0910d34dfd08ef7b90621a7bba59">start</a> (detail::AsyncBidiStreamingReactorFn&lt; StubAsync, Request, Response &gt; fn, StubAsync *stub)</td></tr>
<tr class="memdesc:a29dd0910d34dfd08ef7b90621a7bba59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a codegen-ed rpc.  <br /></td></tr>
<tr class="separator:a29dd0910d34dfd08ef7b90621a7bba59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc3e0d749f2616e7e76f1e81b05d865" id="r_a0fc3e0d749f2616e7e76f1e81b05d865"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a0fc3e0d749f2616e7e76f1e81b05d865"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0fc3e0d749f2616e7e76f1e81b05d865">wait_for_initial_metadata</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a0fc3e0d749f2616e7e76f1e81b05d865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for initial metadata.  <br /></td></tr>
<tr class="separator:a0fc3e0d749f2616e7e76f1e81b05d865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af114aded7cf3cdf1148b69b26b162bd3" id="r_af114aded7cf3cdf1148b69b26b162bd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af114aded7cf3cdf1148b69b26b162bd3">initiate_read</a> (Response &amp;response)</td></tr>
<tr class="memdesc:af114aded7cf3cdf1148b69b26b162bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read message.  <br /></td></tr>
<tr class="separator:af114aded7cf3cdf1148b69b26b162bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2f78a98957eb28579833fea0ecdeea" id="r_a3c2f78a98957eb28579833fea0ecdeea"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a3c2f78a98957eb28579833fea0ecdeea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c2f78a98957eb28579833fea0ecdeea">wait_for_read</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a3c2f78a98957eb28579833fea0ecdeea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for write.  <br /></td></tr>
<tr class="separator:a3c2f78a98957eb28579833fea0ecdeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77205132d783e3404c669b53cb015017" id="r_a77205132d783e3404c669b53cb015017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77205132d783e3404c669b53cb015017">initiate_write</a> (const Request &amp;request, grpc::WriteOptions options={})</td></tr>
<tr class="memdesc:a77205132d783e3404c669b53cb015017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write message.  <br /></td></tr>
<tr class="separator:a77205132d783e3404c669b53cb015017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a158c126bc3900607f9cc339d3a55a4" id="r_a9a158c126bc3900607f9cc339d3a55a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a158c126bc3900607f9cc339d3a55a4">initiate_writes_done</a> ()</td></tr>
<tr class="memdesc:a9a158c126bc3900607f9cc339d3a55a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the rpc will have no more write operations.  <br /></td></tr>
<tr class="separator:a9a158c126bc3900607f9cc339d3a55a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542fb606332cde590ecde8da03c67368" id="r_a542fb606332cde590ecde8da03c67368"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a542fb606332cde590ecde8da03c67368"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a542fb606332cde590ecde8da03c67368">wait_for_write</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a542fb606332cde590ecde8da03c67368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for write.  <br /></td></tr>
<tr class="separator:a542fb606332cde590ecde8da03c67368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa340dddd6b7f1dabb6e573782e64a629" id="r_aa340dddd6b7f1dabb6e573782e64a629"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:aa340dddd6b7f1dabb6e573782e64a629"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa340dddd6b7f1dabb6e573782e64a629">wait_for_writes_done</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:aa340dddd6b7f1dabb6e573782e64a629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for writes done.  <br /></td></tr>
<tr class="separator:aa340dddd6b7f1dabb6e573782e64a629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e2cb94553c144adaa13ed21852ab95" id="r_a23e2cb94553c144adaa13ed21852ab95"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a23e2cb94553c144adaa13ed21852ab95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a23e2cb94553c144adaa13ed21852ab95">wait_for_finish</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a23e2cb94553c144adaa13ed21852ab95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for finish.  <br /></td></tr>
<tr class="separator:a23e2cb94553c144adaa13ed21852ab95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c445971590ac7faa30a097acdca064" id="r_ac5c445971590ac7faa30a097acdca064"><td class="memItemLeft" align="right" valign="top">const Executor &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_reactor_executor_base.html#ac5c445971590ac7faa30a097acdca064">get_executor</a> () const noexcept</td></tr>
<tr class="memdesc:ac5c445971590ac7faa30a097acdca064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the executor.  <br /></td></tr>
<tr class="separator:ac5c445971590ac7faa30a097acdca064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b8983aa09b885d9f89abc7f2b9b2fc" id="r_a08b8983aa09b885d9f89abc7f2b9b2fc"><td class="memItemLeft" align="right" valign="top"><a id="a08b8983aa09b885d9f89abc7f2b9b2fc" name="a08b8983aa09b885d9f89abc7f2b9b2fc"></a>
grpc::ClientContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>context</b> () noexcept</td></tr>
<tr class="memdesc:a08b8983aa09b885d9f89abc7f2b9b2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying <code>grpc::ClientContext</code> <br /></td></tr>
<tr class="separator:a08b8983aa09b885d9f89abc7f2b9b2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712e4f2d3aae3394fe4c3db5f88d88ac" id="r_a712e4f2d3aae3394fe4c3db5f88d88ac"><td class="memItemLeft" align="right" valign="top"><a id="a712e4f2d3aae3394fe4c3db5f88d88ac" name="a712e4f2d3aae3394fe4c3db5f88d88ac"></a>
const grpc::ClientContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>context</b> () const noexcept</td></tr>
<tr class="memdesc:a712e4f2d3aae3394fe4c3db5f88d88ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying <code>grpc::ClientContext</code> (const overload) <br /></td></tr>
<tr class="separator:a712e4f2d3aae3394fe4c3db5f88d88ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Request, class Response, class Executor&gt;<br />
class agrpc::BasicClientBidiReactor&lt; Request, Response, Executor &gt;</div><p>(experimental) I/O object for client-side, bidi-streaming rpcs </p>
<p>Create an object of this type using <code><a class="el" href="namespaceagrpc.html#a59ca62564b50007b111375aa090e752b" title="Create ReactorPtr.">agrpc::make_reactor</a></code>/<code><a class="el" href="namespaceagrpc.html#a0704072818e6d125ef22b0ae1bbe324e" title="Create ReactorPtr using allocator.">agrpc::allocate_reactor</a></code>.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> bidi_streaming(asio::io_context&amp; io_context, example::v1::Example::Stub&amp; stub)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> ptr = <a class="code hl_function" href="namespaceagrpc.html#a59ca62564b50007b111375aa090e752b">agrpc::make_reactor&lt;agrpc::ClientBidiReactor&lt;example::v1::Request, example::v1::Response&gt;</a>&gt;(</div>
<div class="line">        io_context.get_executor());</div>
<div class="line">    <span class="keyword">auto</span>&amp; rpc = *ptr;</div>
<div class="line">    rpc.start(&amp;example::v1::Example::Stub::async::BidirectionalStreaming, stub.async());</div>
<div class="line">    <span class="keyword">auto</span> request = std::make_unique&lt;example::v1::Request&gt;();</div>
<div class="line">    rpc.initiate_write(*request);</div>
<div class="line">    rpc.wait_for_write(</div>
<div class="line">        [ptr = std::move(ptr), request = std::move(request)](<span class="keyword">const</span> error_code&amp;, <span class="keywordtype">bool</span> ok) <span class="keyword">mutable</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (!ok)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keyword">auto</span>&amp; rpc = *ptr;</div>
<div class="line">            <span class="keyword">auto</span> response = std::make_unique&lt;example::v1::Response&gt;();</div>
<div class="line">            rpc.initiate_read(*response);</div>
<div class="line">            rpc.wait_for_read(</div>
<div class="line">                [ptr = std::move(ptr), response = std::move(response)](<span class="keyword">const</span> error_code&amp;, <span class="keywordtype">bool</span> ok)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">if</span> (!ok)</div>
<div class="line">                    {</div>
<div class="line">                        <span class="keywordflow">return</span>;</div>
<div class="line">                    }</div>
<div class="line">                    ptr-&gt;wait_for_finish(</div>
<div class="line">                        [](<span class="keyword">const</span> error_code&amp;, <span class="keyword">const</span> grpc::Status&amp; status)</div>
<div class="line">                        {</div>
<div class="line">                            <span class="keywordflow">if</span> (!status.ok())</div>
<div class="line">                            {</div>
<div class="line">                                <span class="comment">// ...</span></div>
<div class="line">                            }</div>
<div class="line">                        });</div>
<div class="line">                });</div>
<div class="line">        });</div>
<div class="line">}</div>
</div><!-- fragment --><p>Based on <code>.proto</code> file:</p>
<div class="fragment"><div class="line">syntax = &quot;proto3&quot;;</div>
<div class="line"> </div>
<div class="line">package example.v1;</div>
<div class="line"> </div>
<div class="line">service Example {</div>
<div class="line">  rpc ServerStreaming(Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc ClientStreaming(stream Request) returns (Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc BidirectionalStreaming(stream Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc Unary(Request) returns (Response) {}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Request {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Response {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Executor</td><td>The executor type.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Per-Operation Cancellation</b></p>
<p>All. Cancellation will merely interrupt the act of waiting and does not cancel the underlying rpc.</p>
<dl class="section since"><dt>Since</dt><dd>3.5.0 </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a29dd0910d34dfd08ef7b90621a7bba59" name="a29dd0910d34dfd08ef7b90621a7bba59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29dd0910d34dfd08ef7b90621a7bba59">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request , class Response , class Executor &gt; </div>
<div class="memtemplate">
template&lt;class StubAsync &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::start </td>
          <td>(</td>
          <td class="paramtype">detail::AsyncBidiStreamingReactorFn&lt; StubAsync, Request, Response &gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StubAsync *</td>          <td class="paramname"><span class="paramname"><em>stub</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a codegen-ed rpc. </p>
<p>The response object must remain valid until the rpc is finished. May only be called once.</p>
<ul>
<li>fn Pointer to the protoc generated <code>Stub::async::Method</code>. </li>
</ul>

</div>
</div>
<a id="a0fc3e0d749f2616e7e76f1e81b05d865" name="a0fc3e0d749f2616e7e76f1e81b05d865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc3e0d749f2616e7e76f1e81b05d865">&#9670;&#160;</a></span>wait_for_initial_metadata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request , class Response , class Executor &gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::wait_for_initial_metadata </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for initial metadata. </p>
<p>Only one wait for initial metadata may be outstanding at any time.</p>
<p>Completion signature is <code>void(error_code, bool)</code>. If the bool is <code>false</code> then the rpc failed (cancelled, disconnected, deadline reached, ...). </p>

</div>
</div>
<a id="af114aded7cf3cdf1148b69b26b162bd3" name="af114aded7cf3cdf1148b69b26b162bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af114aded7cf3cdf1148b69b26b162bd3">&#9670;&#160;</a></span>initiate_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request , class Response , class Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::initiate_read </td>
          <td>(</td>
          <td class="paramtype">Response &amp;</td>          <td class="paramname"><span class="paramname"><em>response</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read message. </p>
<p>Initiate the read of a message. The argument must remain valid until the write completes (<code>wait_for_read</code>). </p>

</div>
</div>
<a id="a3c2f78a98957eb28579833fea0ecdeea" name="a3c2f78a98957eb28579833fea0ecdeea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2f78a98957eb28579833fea0ecdeea">&#9670;&#160;</a></span>wait_for_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request , class Response , class Executor &gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::wait_for_read </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for write. </p>
<p>Waits for the completion of a read. Only one wait for write may be outstanding at any time.</p>
<p>Completion signature is <code>void(error_code, bool)</code>. If the bool is <code>false</code> then the rpc failed (cancelled, disconnected, deadline reached, ...). </p>

</div>
</div>
<a id="a77205132d783e3404c669b53cb015017" name="a77205132d783e3404c669b53cb015017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77205132d783e3404c669b53cb015017">&#9670;&#160;</a></span>initiate_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request , class Response , class Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::initiate_write </td>
          <td>(</td>
          <td class="paramtype">const Request &amp;</td>          <td class="paramname"><span class="paramname"><em>request</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">grpc::WriteOptions</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write message. </p>
<p>Initiate the write of a message. The argument must remain valid until the write completes (<code>wait_for_write</code>). If <code>WriteOptions::set_last_message()</code> is present then no more calls to <code>initiate_write</code> or <code>initiate_writes_done</code> are allowed. </p>

</div>
</div>
<a id="a9a158c126bc3900607f9cc339d3a55a4" name="a9a158c126bc3900607f9cc339d3a55a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a158c126bc3900607f9cc339d3a55a4">&#9670;&#160;</a></span>initiate_writes_done()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request , class Response , class Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::initiate_writes_done </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicate that the rpc will have no more write operations. </p>
<p>This can only be issued once for a given rpc. This is not required or allowed if <code>initiate_write</code> with <code>set_last_message()</code> is used since that already has the same implication. Note that calling this means that no more calls to <code>initiate_write</code> or <code>initiate_writes_done</code> are allowed. </p>

</div>
</div>
<a id="a542fb606332cde590ecde8da03c67368" name="a542fb606332cde590ecde8da03c67368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542fb606332cde590ecde8da03c67368">&#9670;&#160;</a></span>wait_for_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request , class Response , class Executor &gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::wait_for_write </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for write. </p>
<p>Waits for the completion of a write. Only one wait for write may be outstanding at any time.</p>
<p>Completion signature is <code>void(error_code, bool)</code>. If the bool is <code>false</code> then the rpc failed (cancelled, disconnected, deadline reached, ...). </p>

</div>
</div>
<a id="aa340dddd6b7f1dabb6e573782e64a629" name="aa340dddd6b7f1dabb6e573782e64a629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa340dddd6b7f1dabb6e573782e64a629">&#9670;&#160;</a></span>wait_for_writes_done()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request , class Response , class Executor &gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::wait_for_writes_done </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for writes done. </p>
<p>Waits for the completion of <code>writes_done</code>. Only one wait for write may be outstanding at any time.</p>
<p>Completion signature is <code>void(error_code, bool)</code>. If the bool is <code>false</code> then the rpc failed (cancelled, disconnected, deadline reached, ...). </p>

</div>
</div>
<a id="a23e2cb94553c144adaa13ed21852ab95" name="a23e2cb94553c144adaa13ed21852ab95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e2cb94553c144adaa13ed21852ab95">&#9670;&#160;</a></span>wait_for_finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request , class Response , class Executor &gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">agrpc::BasicClientBidiReactor</a>&lt; Request, Response, Executor &gt;::wait_for_finish </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for finish. </p>
<p>Wait until all operations associated with this rpc have completed. No more reads or writes may be initiated on this rpc after this function has been called. Only one wait for finish may be outstanding at any time.</p>
<p>Completion signature is <code>void(error_code, grpc::Status)</code>. </p>

</div>
</div>
<a id="ac5c445971590ac7faa30a097acdca064" name="ac5c445971590ac7faa30a097acdca064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c445971590ac7faa30a097acdca064">&#9670;&#160;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Executor &amp; <a class="el" href="classagrpc_1_1detail_1_1_reactor_executor_base.html">agrpc::detail::ReactorExecutorBase</a>&lt; Executor &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the executor. </p>
<p>Thread-safe </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceagrpc.html">agrpc</a></li><li class="navelem"><a class="el" href="classagrpc_1_1_basic_client_bidi_reactor.html">BasicClientBidiReactor</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
