<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asio-grpc: agrpc::BasicClientReadReactor&lt; Response, Executor &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">asio-grpc<span id="projectnumber">&#160;v3.6.0</span>
   </div>
   <div id="projectbrief">Asynchronous gRPC with Asio/unified executors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classagrpc_1_1_basic_client_read_reactor.html','','classagrpc_1_1_basic_client_read_reactor-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">agrpc::BasicClientReadReactor&lt; Response, Executor &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>(experimental) I/O object for client-side, server-streaming rpcs  
 <a href="#details">More...</a></p>

<p><code>#include &lt;agrpc/client_callback.hpp&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Inheritance diagram for agrpc::BasicClientReadReactor&lt; Response, Executor &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classagrpc_1_1_basic_client_read_reactor__inherit__graph.png" border="0" usemap="#aagrpc_1_1_basic_client_read_reactor_3_01_response_00_01_executor_01_4_inherit__map" loading="lazy" alt="Inheritance graph"/></div>
<map name="aagrpc_1_1_basic_client_read_reactor_3_01_response_00_01_executor_01_4_inherit__map" id="aagrpc_1_1_basic_client_read_reactor_3_01_response_00_01_executor_01_4_inherit__map">
<area shape="rect" title="(experimental) I/O object for client&#45;side, server&#45;streaming rpcs" alt="" coords="5,93,228,133"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_reactor_executor_base.html" title="Reactor&#39;s executor base." alt="" coords="8,5,225,45"/>
<area shape="poly" title=" " alt="" coords="119,59,119,93,114,93,114,59"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Collaboration diagram for agrpc::BasicClientReadReactor&lt; Response, Executor &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classagrpc_1_1_basic_client_read_reactor__coll__graph.png" border="0" usemap="#aagrpc_1_1_basic_client_read_reactor_3_01_response_00_01_executor_01_4_coll__map" loading="lazy" alt="Collaboration graph"/></div>
<map name="aagrpc_1_1_basic_client_read_reactor_3_01_response_00_01_executor_01_4_coll__map" id="aagrpc_1_1_basic_client_read_reactor_3_01_response_00_01_executor_01_4_coll__map">
<area shape="rect" title="(experimental) I/O object for client&#45;side, server&#45;streaming rpcs" alt="" coords="5,93,228,133"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_reactor_executor_base.html" title="Reactor&#39;s executor base." alt="" coords="8,5,225,45"/>
<area shape="poly" title=" " alt="" coords="119,59,119,93,114,93,114,59"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:rebind_5Fexecutor" id="r_rebind_5Fexecutor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structagrpc_1_1_basic_client_read_reactor_1_1rebind__executor.html">rebind_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind the <a class="el" href="classagrpc_1_1_basic_client_read_reactor.html" title="(experimental) I/O object for client-side, server-streaming rpcs">BasicClientReadReactor</a> to another executor.  <a href="structagrpc_1_1_basic_client_read_reactor_1_1rebind__executor.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac75fc4f9baf950aaf3e2281fc83846d0" id="r_ac75fc4f9baf950aaf3e2281fc83846d0"><td class="memItemLeft" align="right" valign="top"><a id="ac75fc4f9baf950aaf3e2281fc83846d0" name="ac75fc4f9baf950aaf3e2281fc83846d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>executor_type</b> = Executor</td></tr>
<tr class="memdesc:ac75fc4f9baf950aaf3e2281fc83846d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The executor type. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6bbcc770d8a62207508d44f3baac24e0" id="r_a6bbcc770d8a62207508d44f3baac24e0"><td class="memTemplParams" colspan="2">template&lt;class StubAsync, class Request&gt; </td></tr>
<tr class="memitem:a6bbcc770d8a62207508d44f3baac24e0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bbcc770d8a62207508d44f3baac24e0">start</a> (detail::AsyncServerStreamingReactorFn&lt; StubAsync, Request, Response &gt; fn, StubAsync *stub, const Request &amp;request)</td></tr>
<tr class="memdesc:a6bbcc770d8a62207508d44f3baac24e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a codegen-ed rpc.  <br /></td></tr>
<tr class="memitem:a5642ff8ab1bc244ad13fdaa04cd138e7" id="r_a5642ff8ab1bc244ad13fdaa04cd138e7"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a5642ff8ab1bc244ad13fdaa04cd138e7 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5642ff8ab1bc244ad13fdaa04cd138e7">wait_for_initial_metadata</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a5642ff8ab1bc244ad13fdaa04cd138e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for initial metadata.  <br /></td></tr>
<tr class="memitem:a53fd7d052fc201a1b72fdf42cf2e19c5" id="r_a53fd7d052fc201a1b72fdf42cf2e19c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53fd7d052fc201a1b72fdf42cf2e19c5">initiate_read</a> (Response &amp;response)</td></tr>
<tr class="memdesc:a53fd7d052fc201a1b72fdf42cf2e19c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read message.  <br /></td></tr>
<tr class="memitem:a487762bbea9c638bc2e33e7ca42bb51c" id="r_a487762bbea9c638bc2e33e7ca42bb51c"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a487762bbea9c638bc2e33e7ca42bb51c template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a487762bbea9c638bc2e33e7ca42bb51c">wait_for_read</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a487762bbea9c638bc2e33e7ca42bb51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for write.  <br /></td></tr>
<tr class="memitem:a11db31bad8767bc61852604642962a98" id="r_a11db31bad8767bc61852604642962a98"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a11db31bad8767bc61852604642962a98 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11db31bad8767bc61852604642962a98">wait_for_finish</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a11db31bad8767bc61852604642962a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for finish.  <br /></td></tr>
<tr class="memitem:ac5c445971590ac7faa30a097acdca064" id="r_ac5c445971590ac7faa30a097acdca064"><td class="memItemLeft" align="right" valign="top">const Executor &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_reactor_executor_base.html#ac5c445971590ac7faa30a097acdca064">get_executor</a> () const noexcept</td></tr>
<tr class="memdesc:ac5c445971590ac7faa30a097acdca064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the executor.  <br /></td></tr>
<tr class="memitem:a08b8983aa09b885d9f89abc7f2b9b2fc" id="r_a08b8983aa09b885d9f89abc7f2b9b2fc"><td class="memItemLeft" align="right" valign="top"><a id="a08b8983aa09b885d9f89abc7f2b9b2fc" name="a08b8983aa09b885d9f89abc7f2b9b2fc"></a>
grpc::ClientContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>context</b> () noexcept</td></tr>
<tr class="memdesc:a08b8983aa09b885d9f89abc7f2b9b2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying <span class="tt">grpc::ClientContext</span> <br /></td></tr>
<tr class="memitem:a712e4f2d3aae3394fe4c3db5f88d88ac" id="r_a712e4f2d3aae3394fe4c3db5f88d88ac"><td class="memItemLeft" align="right" valign="top"><a id="a712e4f2d3aae3394fe4c3db5f88d88ac" name="a712e4f2d3aae3394fe4c3db5f88d88ac"></a>
const grpc::ClientContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>context</b> () const noexcept</td></tr>
<tr class="memdesc:a712e4f2d3aae3394fe4c3db5f88d88ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying <span class="tt">grpc::ClientContext</span> (const overload) <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Response, class Executor&gt;<br />
class agrpc::BasicClientReadReactor&lt; Response, Executor &gt;</div><p>(experimental) I/O object for client-side, server-streaming rpcs </p>
<p>Create an object of this type using <span class="tt"><a class="el" href="namespaceagrpc.html#a59ca62564b50007b111375aa090e752b" title="Create ReactorPtr.">agrpc::make_reactor</a></span>/<span class="tt"><a class="el" href="namespaceagrpc.html#a0704072818e6d125ef22b0ae1bbe324e" title="Create ReactorPtr using allocator.">agrpc::allocate_reactor</a></span>.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> server_streaming(asio::io_context&amp; io_context, example::v1::Example::Stub&amp; stub)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> ptr = <a class="code hl_function" href="namespaceagrpc.html#a59ca62564b50007b111375aa090e752b">agrpc::make_reactor&lt;agrpc::ClientReadReactor&lt;example::v1::Response&gt;</a>&gt;(io_context.get_executor());</div>
<div class="line">    <span class="keyword">auto</span>&amp; rpc = *ptr;</div>
<div class="line">    <span class="keyword">auto</span> request = std::make_unique&lt;example::v1::Request&gt;();</div>
<div class="line">    rpc.start(&amp;example::v1::Example::Stub::async::ServerStreaming, stub.async(), *request);</div>
<div class="line">    <span class="keyword">auto</span> response = std::make_unique&lt;example::v1::Response&gt;();</div>
<div class="line">    rpc.initiate_read(*response);</div>
<div class="line">    rpc.wait_for_read(</div>
<div class="line">        [ptr = std::move(ptr), request = std::move(request), response = std::move(response)](<span class="keyword">const</span> error_code&amp;,</div>
<div class="line">                                                                                             <span class="keywordtype">bool</span> ok) <span class="keyword">mutable</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (!ok)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            ptr-&gt;wait_for_finish(</div>
<div class="line">                [request = std::move(request)](<span class="keyword">const</span> error_code&amp;, <span class="keyword">const</span> grpc::Status&amp; status)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">if</span> (!status.ok())</div>
<div class="line">                    {</div>
<div class="line">                        <span class="comment">// ...</span></div>
<div class="line">                    }</div>
<div class="line">                });</div>
<div class="line">        });</div>
<div class="line">}</div>
</div><!-- fragment --><p>Based on <span class="tt">.proto</span> file:</p>
<div class="fragment"><div class="line">syntax = &quot;proto3&quot;;</div>
<div class="line"> </div>
<div class="line">package example.v1;</div>
<div class="line"> </div>
<div class="line">service Example {</div>
<div class="line">  rpc ServerStreaming(Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc ClientStreaming(stream Request) returns (Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc BidirectionalStreaming(stream Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc Unary(Request) returns (Response) {}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Request {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Response {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Executor</td><td>The executor type.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Per-Operation Cancellation</b></p>
<p>All. Cancellation will merely interrupt the act of waiting and does not cancel the underlying rpc.</p>
<dl class="section since"><dt>Since</dt><dd>3.5.0 </dd></dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a6bbcc770d8a62207508d44f3baac24e0" name="a6bbcc770d8a62207508d44f3baac24e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbcc770d8a62207508d44f3baac24e0">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Response, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class StubAsync, class Request&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagrpc_1_1_basic_client_read_reactor.html">agrpc::BasicClientReadReactor</a>&lt; Response, Executor &gt;::start </td>
          <td>(</td>
          <td class="paramtype">detail::AsyncServerStreamingReactorFn&lt; StubAsync, Request, Response &gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StubAsync *</td>          <td class="paramname"><span class="paramname"><em>stub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Request &amp;</td>          <td class="paramname"><span class="paramname"><em>request</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a codegen-ed rpc. </p>
<p>The request object must remain valid until the rpc is finished. May only be called once.</p>
<ul>
<li>fn Pointer to the protoc generated <span class="tt">Stub::async::Method</span>. </li>
</ul>

</div>
</div>
<a id="a5642ff8ab1bc244ad13fdaa04cd138e7" name="a5642ff8ab1bc244ad13fdaa04cd138e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5642ff8ab1bc244ad13fdaa04cd138e7">&#9670;&#160;</a></span>wait_for_initial_metadata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Response, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_basic_client_read_reactor.html">agrpc::BasicClientReadReactor</a>&lt; Response, Executor &gt;::wait_for_initial_metadata </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for initial metadata. </p>
<p>Only one wait for initial metadata may be outstanding at any time.</p>
<p>Completion signature is <span class="tt">void(error_code, bool)</span>. If the bool is <span class="tt">false</span> then the rpc failed (cancelled, disconnected, deadline reached, ...). </p>

</div>
</div>
<a id="a53fd7d052fc201a1b72fdf42cf2e19c5" name="a53fd7d052fc201a1b72fdf42cf2e19c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fd7d052fc201a1b72fdf42cf2e19c5">&#9670;&#160;</a></span>initiate_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Response, class Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagrpc_1_1_basic_client_read_reactor.html">agrpc::BasicClientReadReactor</a>&lt; Response, Executor &gt;::initiate_read </td>
          <td>(</td>
          <td class="paramtype">Response &amp;</td>          <td class="paramname"><span class="paramname"><em>response</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read message. </p>
<p>Initiate the read of a message. The argument must remain valid until the write completes (<span class="tt">wait_for_read</span>). </p>

</div>
</div>
<a id="a487762bbea9c638bc2e33e7ca42bb51c" name="a487762bbea9c638bc2e33e7ca42bb51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487762bbea9c638bc2e33e7ca42bb51c">&#9670;&#160;</a></span>wait_for_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Response, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_basic_client_read_reactor.html">agrpc::BasicClientReadReactor</a>&lt; Response, Executor &gt;::wait_for_read </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for write. </p>
<p>Waits for the completion of a read. Only one wait for write may be outstanding at any time.</p>
<p>Completion signature is <span class="tt">void(error_code, bool)</span>. If the bool is <span class="tt">false</span> then the rpc failed (cancelled, disconnected, deadline reached, ...). </p>

</div>
</div>
<a id="a11db31bad8767bc61852604642962a98" name="a11db31bad8767bc61852604642962a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11db31bad8767bc61852604642962a98">&#9670;&#160;</a></span>wait_for_finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Response, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_basic_client_read_reactor.html">agrpc::BasicClientReadReactor</a>&lt; Response, Executor &gt;::wait_for_finish </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for finish. </p>
<p>Wait until all operations associated with this rpc have completed. No more reads may be initiated on this rpc after this function has been called. Only one wait for finish may be outstanding at any time.</p>
<p>Completion signature is <span class="tt">void(error_code, grpc::Status)</span>. </p>

</div>
</div>
<a id="ac5c445971590ac7faa30a097acdca064" name="ac5c445971590ac7faa30a097acdca064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c445971590ac7faa30a097acdca064">&#9670;&#160;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Executor &amp; <a class="el" href="classagrpc_1_1detail_1_1_reactor_executor_base.html">agrpc::detail::ReactorExecutorBase</a>&lt; Executor &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the executor. </p>
<p>Thread-safe </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceagrpc.html">agrpc</a></li><li class="navelem"><a href="classagrpc_1_1_basic_client_read_reactor.html">BasicClientReadReactor</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
