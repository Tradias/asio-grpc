<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asio-grpc: Using Asio io_context</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">asio-grpc<span id="projectnumber">&#160;v3.5.0</span>
   </div>
   <div id="projectbrief">Asynchronous gRPC with Asio/unified executors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_doc_2using__asio__io__context.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Using Asio io_context</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md19"></a></p>
<dl class="section note"><dt>Note</dt><dd>Due to limitations of the gRPC CompletionQueue and Callback API an <a href="https://www.boost.org/doc/libs/1_86_0/doc/html/boost_asio/reference/io_context.html">asio::io_context</a> cannot be used to handle RPCs directly. See the end of this document for a detailed explanation.</dd></dl>
<p>This article describes how to interoperate between a GrpcContext and an <a href="https://www.boost.org/doc/libs/1_86_0/doc/html/boost_asio/reference/io_context.html">asio::io_context</a>.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Implicitly constructed io_context</h1>
<p>Since a GrpcContext is also an <a href="https://www.boost.org/doc/libs/1_86_0/doc/html/boost_asio/reference/execution_context.html">asio::execution_context</a> it supports Asio's <a href="https://www.boost.org/doc/libs/1_86_0/doc/html/boost_asio/reference/Service.html">Service</a> mechanism. The following code will therefore implicitly create an io_context, a background thread, run the io_context on that thread and post the completion of <code>async_wait</code> onto the GrpcContext where the lambda is being invoked.</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a> grpc_context;</div>
<div class="line">    asio::signal_set signals{grpc_context, SIGINT, SIGTERM};</div>
<div class="line">    signals.async_wait(</div>
<div class="line">        [](<span class="keyword">const</span> std::error_code&amp;, <span class="keywordtype">int</span>)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// executed in the thread that called grpc_context.run().</span></div>
<div class="line">        });</div>
<div class="line">    grpc_context.<a class="code hl_function" href="classagrpc_1_1_grpc_context.html#acb1dae170b054aba4c83e266c456fee0">run</a>();</div>
</div><!-- fragment --><p>Signal_set is just used as an example, it could be any Asio I/O object like <code>ip::tcp::socket</code>.</p>
<p>While this is the most convenient approach is also has some downsides:</p>
<ul>
<li>The io_context cannot be run on more than one thread.</li>
<li>There is runtime overhead due to non-customizable thread switching.</li>
</ul>
<h1><a class="anchor" id="autotoc_md21"></a>
Explicitly constructed io_context</h1>
<p>GrpcContext and io_context can also be created directly and used as usual: submit work and run. It is often convenient to utilize one of them as the "main" context. For an example, a gRPC server might use the io_context only for HTTP client operations and the GrpcContext for everything else.</p>
<p>In the following example the io_context is used as the "main" context. When its main coroutine runs to completion, it will signal the GrpcContext to stop (by releasing the work guard):</p>
<div class="fragment"><div class="line">    asio::io_context io_context{1};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a></div>
<div class="line">        grpc_context;  <span class="comment">// for gRPC servers this would be constructed using `grpc::ServerBuilder::AddCompletionQueue`</span></div>
<div class="line"> </div>
<div class="line">    asio::co_spawn(</div>
<div class="line">        io_context,  <span class="comment">// Spawning onto the io_context means that completed operations will switch back to the it before</span></div>
<div class="line">                     <span class="comment">// resuming the coroutine. This can be customized on a per-operation basis using</span></div>
<div class="line">                     <span class="comment">// `asio::bind_executor`.</span></div>
<div class="line">        [&amp;, grpc_context_work_guard = asio::make_work_guard(grpc_context)]() <span class="keyword">mutable</span> -&gt; asio::awaitable&lt;void&gt;</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">using namespace </span>asio::experimental::awaitable_operators;</div>
<div class="line">            <span class="keyword">co_await</span> (make_grpc_request(grpc_context, stub) &amp;&amp; make_tcp_request(tcp_port));</div>
<div class="line">            grpc_context_work_guard.reset();</div>
<div class="line">        },</div>
<div class="line">        example::RethrowFirstArg{});</div>
</div><!-- fragment --><p>For running the contexts there are two choices:</p>
<p><b>Run on separate threads</b></p>
<div class="fragment"><div class="line">    std::thread grpc_context_thread{[&amp;]</div>
<div class="line">                                    {</div>
<div class="line">                                        grpc_context.<a class="code hl_function" href="classagrpc_1_1_grpc_context.html#acb1dae170b054aba4c83e266c456fee0">run</a>();</div>
<div class="line">                                    }};</div>
<div class="line">    io_context.<a class="code hl_function" href="classagrpc_1_1_grpc_context.html#acb1dae170b054aba4c83e266c456fee0">run</a>();</div>
<div class="line">    grpc_context_thread.join();</div>
</div><!-- fragment --><p><b>Run on same thread</b></p>
<p>Until the GrpcContext stops:</p>
<div class="fragment"><div class="line">    <span class="comment">// First, initiate the io_context&#39;s thread_local variables by posting on it. The io_context uses them to optimize</span></div>
<div class="line">    <span class="comment">// dynamic memory allocations. This is an optional step but it can improve performance.</span></div>
<div class="line">    asio::post(io_context,</div>
<div class="line">               [&amp;]</div>
<div class="line">               {</div>
<div class="line">                   <a class="code hl_function" href="namespaceagrpc.html#ab52a5b6f6ce90d1bc9faa5baa96a39fa">agrpc::run</a>(grpc_context, io_context,</div>
<div class="line">                              [&amp;]</div>
<div class="line">                              {</div>
<div class="line">                                  <span class="keywordflow">return</span> grpc_context.<a class="code hl_function" href="classagrpc_1_1_grpc_context.html#af71bfc1a827acb00e275161f189ea151">is_stopped</a>();</div>
<div class="line">                              });</div>
<div class="line">               });</div>
<div class="line">    io_context.<a class="code hl_function" href="classagrpc_1_1_grpc_context.html#acb1dae170b054aba4c83e266c456fee0">run</a>();</div>
</div><!-- fragment --><p>Or until both contexts stop:</p>
<div class="fragment"><div class="line">    <span class="comment">// First, initiate the io_context&#39;s thread_local variables by posting on it. The io_context uses them to optimize</span></div>
<div class="line">    <span class="comment">// dynamic memory allocations. This is an optional step but it can improve performance.</span></div>
<div class="line">    <span class="comment">// Then undo the work counting of asio::post.</span></div>
<div class="line">    <span class="comment">// Run GrpcContext and io_context until both stop.</span></div>
<div class="line">    <span class="comment">// Finally, redo the work counting.</span></div>
<div class="line">    asio::post(io_context,</div>
<div class="line">               [&amp;]</div>
<div class="line">               {</div>
<div class="line">                   io_context.get_executor().on_work_finished();</div>
<div class="line">                   <a class="code hl_function" href="namespaceagrpc.html#ab52a5b6f6ce90d1bc9faa5baa96a39fa">agrpc::run</a>(grpc_context, io_context);</div>
<div class="line">                   io_context.get_executor().on_work_started();</div>
<div class="line">               });</div>
<div class="line">    io_context.<a class="code hl_function" href="classagrpc_1_1_grpc_context.html#acb1dae170b054aba4c83e266c456fee0">run</a>();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md22"></a>
Conclusion</h2>
<p>Both approaches come with their own different kind of overheads. Running on two threads might require additional synchronization in the user code while running on the same thread reduces peak performance. In the <a href="https://github.com/Tradias/asio-grpc#performance">Performance</a> section of the README you can find results for using an idle io_context with a busy GrpcContext running on the same thread (look for <code>cpp_asio_grpc_io_context_coro</code>).</p>
<h1><a class="anchor" id="autotoc_md23"></a>
Why not use io_context for gRPC directly?</h1>
<p>Event loops like the ones used in Asio and gRPC typically utilize system APIs (epoll, IOCompletionPorts, kqueue, ...) in the following order:</p>
<ol type="1">
<li>Create file descriptors for network operations (e.g. sockets and pipes).</li>
<li>Initiate some operations on those descriptors (e.g. read and write).</li>
<li>Perform a system call (e.g. <code>poll</code>) to sleep on ALL descriptors until one or more are ready (e.g. received data).</li>
<li>Notify some part of the application, typically by invoking a function pointer.</li>
</ol>
<p>The important part is to wait on ALL descriptors at once. Which means, for Asio and gRPC to interoperate nicely we would need to collect the descriptors first and then perform the system call to wait. However, file descriptors are created deep in the implementation details of those libraries and the sleep is performed even deeper. GRPC is working on an <a href="https://github.com/grpc/grpc/blob/master/include/grpc/event_engine/README.md">EventEngine</a> which should make it possible to use Asio sockets for gRPC. Whether it will be enough to fully use Asio for all gRPC network operations remains to be seen. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
