<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asio-grpc: agrpc::ClientRPC&lt; PrepareAsyncBidiStreaming, Executor &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">asio-grpc<span id="projectnumber">&#160;v3.6.0</span>
   </div>
   <div id="projectbrief">Asynchronous gRPC with Asio/unified executors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4.html','','classagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">agrpc::ClientRPC&lt; PrepareAsyncBidiStreaming, Executor &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>I/O object for client-side, bidirectional-streaming rpcs.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;agrpc/client_rpc.hpp&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Inheritance diagram for agrpc::ClientRPC&lt; PrepareAsyncBidiStreaming, Executor &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4__inherit__graph.png" border="0" usemap="#aagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_inherit__map" loading="lazy" alt="Inheritance graph"/></div>
<map name="aagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_inherit__map" id="aagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_inherit__map">
<area shape="rect" title="I/O object for client&#45;side, bidirectional&#45;streaming rpcs." alt="" coords="908,41,1140,81"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html" title="Bidirectional&#45;streaming ClientRPC base." alt="" coords="589,34,860,89"/>
<area shape="poly" title=" " alt="" coords="874,59,908,59,908,64,874,64"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_client_r_p_c_base.html" title=" " alt="" coords="280,34,541,89"/>
<area shape="poly" title=" " alt="" coords="555,59,589,59,589,64,555,64"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html" title="RPC&#39;s executor base." alt="" coords="22,5,215,45"/>
<area shape="poly" title=" " alt="" coords="230,36,280,43,279,48,229,42"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_client_r_p_c_context_base.html" title=" " alt="" coords="5,70,232,125"/>
<area shape="poly" title=" " alt="" coords="245,79,279,75,280,80,246,84"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Collaboration diagram for agrpc::ClientRPC&lt; PrepareAsyncBidiStreaming, Executor &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4__coll__graph.png" border="0" usemap="#aagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_coll__map" loading="lazy" alt="Collaboration graph"/></div>
<map name="aagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_coll__map" id="aagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_coll__map">
<area shape="rect" title="I/O object for client&#45;side, bidirectional&#45;streaming rpcs." alt="" coords="908,41,1140,81"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html" title="Bidirectional&#45;streaming ClientRPC base." alt="" coords="589,34,860,89"/>
<area shape="poly" title=" " alt="" coords="874,59,908,59,908,64,874,64"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_client_r_p_c_base.html" title=" " alt="" coords="280,34,541,89"/>
<area shape="poly" title=" " alt="" coords="555,59,589,59,589,64,555,64"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html" title="RPC&#39;s executor base." alt="" coords="22,5,215,45"/>
<area shape="poly" title=" " alt="" coords="230,36,280,43,279,48,229,42"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_client_r_p_c_context_base.html" title=" " alt="" coords="5,70,232,125"/>
<area shape="poly" title=" " alt="" coords="245,79,279,75,280,80,246,84"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:rebind_5Fexecutor" id="r_rebind_5Fexecutor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_1_1rebind__executor.html">rebind_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind the <a class="el" href="classagrpc_1_1_client_r_p_c.html" title="Primary ClientRPC template.">ClientRPC</a> to another executor.  <a href="structagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_1_1rebind__executor.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4ad1384caca1951c4d7b4b68b1387bb9" id="r_a4ad1384caca1951c4d7b4b68b1387bb9"><td class="memItemLeft" align="right" valign="top"><a id="a4ad1384caca1951c4d7b4b68b1387bb9" name="a4ad1384caca1951c4d7b4b68b1387bb9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Stub</b> = StubT</td></tr>
<tr class="memdesc:a4ad1384caca1951c4d7b4b68b1387bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stub type. <br /></td></tr>
<tr class="memitem:ab17fb315d9316707b442296f9096519c" id="r_ab17fb315d9316707b442296f9096519c"><td class="memItemLeft" align="right" valign="top"><a id="ab17fb315d9316707b442296f9096519c" name="ab17fb315d9316707b442296f9096519c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Request</b> = RequestT</td></tr>
<tr class="memdesc:ab17fb315d9316707b442296f9096519c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The request message type. <br /></td></tr>
<tr class="memitem:a09949deac664f28273aa1b4f806759b1" id="r_a09949deac664f28273aa1b4f806759b1"><td class="memItemLeft" align="right" valign="top"><a id="a09949deac664f28273aa1b4f806759b1" name="a09949deac664f28273aa1b4f806759b1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Response</b> = ResponseT</td></tr>
<tr class="memdesc:a09949deac664f28273aa1b4f806759b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The response message type. <br /></td></tr>
<tr class="memitem:afe3aab926de22d76fdb5e0d347c5d8c4" id="r_afe3aab926de22d76fdb5e0d347c5d8c4"><td class="memItemLeft" align="right" valign="top"><a id="afe3aab926de22d76fdb5e0d347c5d8c4" name="afe3aab926de22d76fdb5e0d347c5d8c4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>executor_type</b> = Executor</td></tr>
<tr class="memdesc:afe3aab926de22d76fdb5e0d347c5d8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The executor type. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa30e41480cbb07e971de447834423cdd" id="r_aa30e41480cbb07e971de447834423cdd"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:aa30e41480cbb07e971de447834423cdd template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa30e41480cbb07e971de447834423cdd">start</a> (StubT &amp;stub, CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:aa30e41480cbb07e971de447834423cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a bidirectional-streaming request.  <br /></td></tr>
<tr class="memitem:afb6a4be476b5cab862000ba87b70e289" id="r_afb6a4be476b5cab862000ba87b70e289"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:afb6a4be476b5cab862000ba87b70e289 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#afb6a4be476b5cab862000ba87b70e289">read_initial_metadata</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:afb6a4be476b5cab862000ba87b70e289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read initial metadata.  <br /></td></tr>
<tr class="memitem:ad3830bd5b441d8b80c2a5dd33ae8ad2d" id="r_ad3830bd5b441d8b80c2a5dd33ae8ad2d"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:ad3830bd5b441d8b80c2a5dd33ae8ad2d template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#ad3830bd5b441d8b80c2a5dd33ae8ad2d">read</a> (ResponseT &amp;response, CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:ad3830bd5b441d8b80c2a5dd33ae8ad2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message from the server.  <br /></td></tr>
<tr class="memitem:a613e43b75d508d451dac44e474256bf8" id="r_a613e43b75d508d451dac44e474256bf8"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a613e43b75d508d451dac44e474256bf8 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a613e43b75d508d451dac44e474256bf8">write</a> (const RequestT &amp;request, grpc::WriteOptions options, CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a613e43b75d508d451dac44e474256bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the server.  <br /></td></tr>
<tr class="memitem:a7617653d30c2f57cdaeffcefed89793f" id="r_a7617653d30c2f57cdaeffcefed89793f"><td class="memTemplParams" colspan="2"><a id="a7617653d30c2f57cdaeffcefed89793f" name="a7617653d30c2f57cdaeffcefed89793f"></a>
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a7617653d30c2f57cdaeffcefed89793f template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (const RequestT &amp;request, CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a7617653d30c2f57cdaeffcefed89793f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the server (default WriteOptions) <br /></td></tr>
<tr class="memitem:a2d19b1441bd69861873989f76f5875e2" id="r_a2d19b1441bd69861873989f76f5875e2"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a2d19b1441bd69861873989f76f5875e2 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a2d19b1441bd69861873989f76f5875e2">writes_done</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a2d19b1441bd69861873989f76f5875e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal writes done to the server.  <br /></td></tr>
<tr class="memitem:a9a9b990891472214354e3425616f7b23" id="r_a9a9b990891472214354e3425616f7b23"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a9a9b990891472214354e3425616f7b23 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a9a9b990891472214354e3425616f7b23">finish</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a9a9b990891472214354e3425616f7b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal writes done and finish the rpc.  <br /></td></tr>
<tr class="memitem:ac7d45c8fc3141d17881ac99ba0b53034" id="r_ac7d45c8fc3141d17881ac99ba0b53034"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html#afe3aab926de22d76fdb5e0d347c5d8c4">executor_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html#ac7d45c8fc3141d17881ac99ba0b53034">get_executor</a> () const noexcept</td></tr>
<tr class="memdesc:ac7d45c8fc3141d17881ac99ba0b53034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the executor.  <br /></td></tr>
<tr class="memitem:ac5e0d6c42c0ed62b84b90f3ce42e180a" id="r_ac5e0d6c42c0ed62b84b90f3ce42e180a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html#afe3aab926de22d76fdb5e0d347c5d8c4">executor_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html#ac5e0d6c42c0ed62b84b90f3ce42e180a">get_scheduler</a> () const noexcept</td></tr>
<tr class="memdesc:ac5e0d6c42c0ed62b84b90f3ce42e180a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scheduler.  <br /></td></tr>
<tr class="memitem:a056f94eadae189c43a6919d09e9f0031" id="r_a056f94eadae189c43a6919d09e9f0031"><td class="memItemLeft" align="right" valign="top"><a id="a056f94eadae189c43a6919d09e9f0031" name="a056f94eadae189c43a6919d09e9f0031"></a>
grpc::ClientContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>context</b> ()</td></tr>
<tr class="memdesc:a056f94eadae189c43a6919d09e9f0031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying <span class="tt">grpc::ClientContext</span> <br /></td></tr>
<tr class="memitem:ade0c1cd5b69a524efbf92059fda88c1c" id="r_ade0c1cd5b69a524efbf92059fda88c1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_context_base.html#ade0c1cd5b69a524efbf92059fda88c1c">cancel</a> () noexcept</td></tr>
<tr class="memdesc:ade0c1cd5b69a524efbf92059fda88c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel this RPC.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a07458f85b4281c361b16f652b6cda493" id="r_a07458f85b4281c361b16f652b6cda493"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07458f85b4281c361b16f652b6cda493">service_name</a> () noexcept</td></tr>
<tr class="memdesc:a07458f85b4281c361b16f652b6cda493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the gRPC service.  <br /></td></tr>
<tr class="memitem:a36e96b31ad3ef1098a4c8c23e9dd94b7" id="r_a36e96b31ad3ef1098a4c8c23e9dd94b7"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36e96b31ad3ef1098a4c8c23e9dd94b7">method_name</a> () noexcept</td></tr>
<tr class="memdesc:a36e96b31ad3ef1098a4c8c23e9dd94b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the gRPC method.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0b85df8344986b161b6223aa80595a6c" id="r_a0b85df8344986b161b6223aa80595a6c"><td class="memItemLeft" align="right" valign="top"><a id="a0b85df8344986b161b6223aa80595a6c" name="a0b85df8344986b161b6223aa80595a6c"></a>
static constexpr <a class="el" href="namespaceagrpc.html#a42c57be5049212df6909b6da0c60d36e">agrpc::ClientRPCType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TYPE</b> = <a class="el" href="namespaceagrpc.html#a42c57be5049212df6909b6da0c60d36eaf92e0d805b776fa75c63d16707f99111">agrpc::ClientRPCType::BIDIRECTIONAL_STREAMING</a></td></tr>
<tr class="memdesc:a0b85df8344986b161b6223aa80595a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rpc type. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class StubT, class RequestT, class ResponseT, template&lt; class, class &gt; class ResponderT, detail::PrepareAsyncClientBidirectionalStreamingRequest&lt; StubT, ResponderT&lt; RequestT, ResponseT &gt; &gt; PrepareAsyncBidiStreaming, class Executor&gt;<br />
class agrpc::ClientRPC&lt; PrepareAsyncBidiStreaming, Executor &gt;</div><p>I/O object for client-side, bidirectional-streaming rpcs. </p>
<p>Example:</p>
<div class="fragment"><div class="line">asio::awaitable&lt;void&gt; client_rpc_bidirectional_streaming(<a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a>&amp; grpc_context,</div>
<div class="line">                                                         example::v1::Example::Stub&amp; stub)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>RPC =</div>
<div class="line">        <a class="code hl_class" href="classagrpc_1_1_client_r_p_c.html">agrpc::ClientRPC&lt;&amp;example::v1::Example::Stub::PrepareAsyncBidirectionalStreaming&gt;</a>;</div>
<div class="line"> </div>
<div class="line">    RPC rpc{grpc_context};</div>
<div class="line">    rpc.context().set_deadline(std::chrono::system_clock::now() +</div>
<div class="line">                               std::chrono::seconds(5));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!<span class="keyword">co_await</span> rpc.start(stub))</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> grpc::Status status = <span class="keyword">co_await</span> rpc.finish();</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Rpc failed: &quot;</span> &lt;&lt; status.error_message();</div>
<div class="line">        <span class="keyword">co_return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    RPC::Request request;</div>
<div class="line">    request.set_integer(42);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> write_ok{<span class="keyword">true</span>};</div>
<div class="line">    RPC::Response response;</div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">co_await</span> rpc.read(response) &amp;&amp; write_ok)</div>
<div class="line">    {</div>
<div class="line">        request.set_integer(response.integer() + 1);</div>
<div class="line">        write_ok = <span class="keyword">co_await</span> rpc.write(request);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> grpc::Status status = <span class="keyword">co_await</span> rpc.finish();</div>
<div class="line">    <span class="keywordflow">if</span> (!status.ok())</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Rpc failed: &quot;</span> &lt;&lt; status.error_message();</div>
<div class="line">        <span class="keyword">co_return</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Based on <span class="tt">.proto</span> file:</p>
<div class="fragment"><div class="line">syntax = &quot;proto3&quot;;</div>
<div class="line"> </div>
<div class="line">package example.v1;</div>
<div class="line"> </div>
<div class="line">service Example {</div>
<div class="line">  rpc ServerStreaming(Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc ClientStreaming(stream Request) returns (Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc BidirectionalStreaming(stream Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc Unary(Request) returns (Response) {}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Request {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Response {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PrepareAsyncBidiStreaming</td><td>A pointer to the generated, async version of the gRPC method. The async version starts with <span class="tt">PrepareAsync</span>. </td></tr>
    <tr><td class="paramname">Executor</td><td>The executor type, must be capable of referring to a <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Per-Operation Cancellation</b></p>
<p>Terminal and partial. Cancellation is performed by invoking <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_client_context.html#abd0f6715c30287b75288015eee628984">grpc::ClientContext::TryCancel</a>. After successful cancellation no further operations may be started on the rpc (except <a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a9a9b990891472214354e3425616f7b23" title="Signal writes done and finish the rpc.">finish()</a>). Operations are also cancelled when the deadline of the rpc has been reached (see <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_client_context.html#ad4e16866fee3f6ee5a10efb5be6f4da6">grpc::ClientContext::set_deadline</a>).</p>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a07458f85b4281c361b16f652b6cda493" name="a07458f85b4281c361b16f652b6cda493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07458f85b4281c361b16f652b6cda493">&#9670;&#160;</a></span>service_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StubT, class RequestT, class ResponseT, template&lt; class, class &gt; class ResponderT, detail::PrepareAsyncClientBidirectionalStreamingRequest&lt; StubT, ResponderT&lt; RequestT, ResponseT &gt; &gt; PrepareAsyncBidiStreaming, class Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::string_view <a class="el" href="classagrpc_1_1_client_r_p_c.html">agrpc::ClientRPC</a>&lt; PrepareAsyncBidiStreaming, Executor &gt;::service_name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of the gRPC service. </p>
<p>Equal to the generated <span class="tt">Service::service_full_name()</span>.</p>
<p>E.g. for the <span class="tt">.proto</span> schema</p>
<div class="fragment"><div class="line">package example.v1;</div>
<div class="line"> </div>
<div class="line">service Example { ... }</div>
</div><!-- fragment --><p>the return value would be <span class="tt">"example.v1.Example"</span>.</p>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="a36e96b31ad3ef1098a4c8c23e9dd94b7" name="a36e96b31ad3ef1098a4c8c23e9dd94b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e96b31ad3ef1098a4c8c23e9dd94b7">&#9670;&#160;</a></span>method_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StubT, class RequestT, class ResponseT, template&lt; class, class &gt; class ResponderT, detail::PrepareAsyncClientBidirectionalStreamingRequest&lt; StubT, ResponderT&lt; RequestT, ResponseT &gt; &gt; PrepareAsyncBidiStreaming, class Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::string_view <a class="el" href="classagrpc_1_1_client_r_p_c.html">agrpc::ClientRPC</a>&lt; PrepareAsyncBidiStreaming, Executor &gt;::method_name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of the gRPC method. </p>
<p>E.g. for <span class="tt"><a class="el" href="classagrpc_1_1_client_r_p_c.html" title="Primary ClientRPC template.">agrpc::ClientRPC</a>&lt;&amp;example::Example::Stub::PrepareAsyncMyMethod&gt;</span> the return value would be <span class="tt">"MyMethod"</span>.</p>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="aa30e41480cbb07e971de447834423cdd" name="aa30e41480cbb07e971de447834423cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30e41480cbb07e971de447834423cdd">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StubT, class RequestT, class ResponseT, template&lt; class, class &gt; class ResponderT, detail::PrepareAsyncClientBidirectionalStreamingRequest&lt; StubT, ResponderT&lt; RequestT, ResponseT &gt; &gt; PrepareAsyncBidiStreaming, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_client_r_p_c.html">agrpc::ClientRPC</a>&lt; PrepareAsyncBidiStreaming, Executor &gt;::start </td>
          <td>(</td>
          <td class="paramtype">StubT &amp;</td>          <td class="paramname"><span class="paramname"><em>stub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a bidirectional-streaming request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stub</td><td>The <a class="el" href="#a4ad1384caca1951c4d7b4b68b1387bb9" title="The stub type.">Stub</a> that corresponds to the gRPC method. </td></tr>
    <tr><td class="paramname">token</td><td>A completion token like <span class="tt">asio::yield_context</span> or <span class="tt"><a class="el" href="namespaceagrpc.html#aa9c38be6a3d7d59a78007bc4fff311a4" title="Instance and factory for sender completion tokens.">agrpc::use_sender</a></span>. The completion signature is <span class="tt">void(bool)</span>. <span class="tt">true</span> means that the rpc was started successfully. If it is <span class="tt">false</span>, then call <span class="tt"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a9a9b990891472214354e3425616f7b23" title="Signal writes done and finish the rpc.">finish()</a></span> to obtain error details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb6a4be476b5cab862000ba87b70e289" name="afb6a4be476b5cab862000ba87b70e289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6a4be476b5cab862000ba87b70e289">&#9670;&#160;</a></span>read_initial_metadata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RequestT, class ResponseT, template&lt; class, class &gt; class ResponderT, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::ClientRPCBidiStreamingBase&lt; ResponderT&lt; RequestT, ResponseT &gt;, Executor &gt;::read_initial_metadata </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read initial metadata. </p>
<p><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#ab17fb315d9316707b442296f9096519c" title="The request message type.">Request</a> notification of the reading of the initial metadata.</p>
<p>This call is optional.</p>
<p>Side effect:</p>
<ul>
<li>Upon receiving initial metadata from the server, the ClientContext associated with this call is updated, and the calling code can access the received metadata through the ClientContext.</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>If the server does not explicitly send initial metadata (e.g. by calling send_initial_metadata()) but waits for a message from the client instead then this function won't complete until <span class="tt"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a613e43b75d508d451dac44e474256bf8" title="Send a message to the server.">write()</a></span> is called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <span class="tt">asio::yield_context</span> or <span class="tt"><a class="el" href="namespaceagrpc.html#aa9c38be6a3d7d59a78007bc4fff311a4" title="Instance and factory for sender completion tokens.">agrpc::use_sender</a></span>. The completion signature is <span class="tt">void(bool)</span>. <span class="tt">true</span> indicates that the metadata was read. If it is <span class="tt">false</span>, then the call is dead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3830bd5b441d8b80c2a5dd33ae8ad2d" name="ad3830bd5b441d8b80c2a5dd33ae8ad2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3830bd5b441d8b80c2a5dd33ae8ad2d">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RequestT, class ResponseT, template&lt; class, class &gt; class ResponderT, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::ClientRPCBidiStreamingBase&lt; ResponderT&lt; RequestT, ResponseT &gt;, Executor &gt;::read </td>
          <td>(</td>
          <td class="paramtype">ResponseT &amp;</td>          <td class="paramname"><span class="paramname"><em>response</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive a message from the server. </p>
<p>This is thread-safe with respect to <span class="tt"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a613e43b75d508d451dac44e474256bf8" title="Send a message to the server.">write()</a></span> or <span class="tt"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a2d19b1441bd69861873989f76f5875e2" title="Signal writes done to the server.">writes_done()</a></span> methods. It should not be called concurrently with other operations. It is not meaningful to call it concurrently with another read on the same stream since reads on the same stream are delivered in order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <span class="tt">asio::yield_context</span> or <span class="tt"><a class="el" href="namespaceagrpc.html#aa9c38be6a3d7d59a78007bc4fff311a4" title="Instance and factory for sender completion tokens.">agrpc::use_sender</a></span>. The completion signature is <span class="tt">void(bool)</span>. <span class="tt">true</span> indicates that a valid message was read. <span class="tt">false</span> when there will be no more incoming messages, either because the other server is finished sending messages or the stream has failed (or been cancelled). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a613e43b75d508d451dac44e474256bf8" name="a613e43b75d508d451dac44e474256bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613e43b75d508d451dac44e474256bf8">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RequestT, class ResponseT, template&lt; class, class &gt; class ResponderT, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::ClientRPCBidiStreamingBase&lt; ResponderT&lt; RequestT, ResponseT &gt;, Executor &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const RequestT &amp;</td>          <td class="paramname"><span class="paramname"><em>request</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">grpc::WriteOptions</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message to the server. </p>
<p>Only one write may be outstanding at any given time. This is thread-safe with respect to <span class="tt"><a class="el" href="namespaceagrpc.html#a685510388ab87c9a90c44f880e9de9cd" title="Read from a streaming RPC.">read()</a></span>. It should not be called concurrently with other operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request message, save to delete when this function returns, unless a deferred completion token is used like <span class="tt"><a class="el" href="namespaceagrpc.html#aa9c38be6a3d7d59a78007bc4fff311a4" title="Instance and factory for sender completion tokens.">agrpc::use_sender</a></span> or <span class="tt">asio::deferred</span>. </td></tr>
    <tr><td class="paramname">token</td><td>A completion token like <span class="tt">asio::yield_context</span> or <span class="tt"><a class="el" href="namespaceagrpc.html#aa9c38be6a3d7d59a78007bc4fff311a4" title="Instance and factory for sender completion tokens.">agrpc::use_sender</a></span>. The completion signature is <span class="tt">void(bool)</span>. <span class="tt">true</span> means that the data is going to go to the wire. If it is <span class="tt">false</span>, it is not going to the wire because the call is already dead (i.e., canceled, deadline expired, other side dropped the channel, etc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d19b1441bd69861873989f76f5875e2" name="a2d19b1441bd69861873989f76f5875e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d19b1441bd69861873989f76f5875e2">&#9670;&#160;</a></span>writes_done()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RequestT, class ResponseT, template&lt; class, class &gt; class ResponderT, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::ClientRPCBidiStreamingBase&lt; ResponderT&lt; RequestT, ResponseT &gt;, Executor &gt;::writes_done </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal writes done to the server. </p>
<p>May only be called once. Should not be called after performing a write with the <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_write_options.html#ad930c28f5c32832e1d48ee30bf0858e3">set_last_message</a> option.</p>
<p>Signal the client is done with the writes (half-close the client stream). Thread-safe with respect to read. May not be called concurrently with a <span class="tt"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a613e43b75d508d451dac44e474256bf8" title="Send a message to the server.">write()</a></span> that has the <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_write_options.html#ad930c28f5c32832e1d48ee30bf0858e3">set_last_message</a> option set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <span class="tt">asio::yield_context</span> or <span class="tt"><a class="el" href="namespaceagrpc.html#aa9c38be6a3d7d59a78007bc4fff311a4" title="Instance and factory for sender completion tokens.">agrpc::use_sender</a></span>. The completion signature is <span class="tt">void(bool)</span>. <span class="tt">true</span> means that the data is going to go to the wire. If it is <span class="tt">false</span>, it is not going to the wire because the call is already dead (i.e., canceled, deadline expired, other side dropped the channel, etc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a9b990891472214354e3425616f7b23" name="a9a9b990891472214354e3425616f7b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9b990891472214354e3425616f7b23">&#9670;&#160;</a></span>finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RequestT, class ResponseT, template&lt; class, class &gt; class ResponderT, class Executor&gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::ClientRPCBidiStreamingBase&lt; ResponderT&lt; RequestT, ResponseT &gt;, Executor &gt;::finish </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal writes done and finish the rpc. </p>
<p>Indicate that the stream is to be finished and request notification for when the call has been ended.</p>
<p>May not be used concurrently with other operations and may only be called once.</p>
<p>It is appropriate to call this method when:</p>
<ul>
<li>All messages from the server have been received (either known implictly, or explicitly because a previous read operation returned <span class="tt">false</span>).</li>
</ul>
<p>The operation will finish when either:</p>
<ul>
<li>The server has returned a status. </li>
<li>The call failed for some reason and the library generated a status.</li>
</ul>
<p>Note that implementations of this method attempt to receive initial metadata from the server if initial metadata has not been received yet.</p>
<p>Side effect:</p>
<ul>
<li>The ClientContext associated with the call is updated with possible initial and trailing metadata received from the server.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <span class="tt">asio::yield_context</span> or <span class="tt"><a class="el" href="namespaceagrpc.html#aa9c38be6a3d7d59a78007bc4fff311a4" title="Instance and factory for sender completion tokens.">agrpc::use_sender</a></span>. The completion signature is <span class="tt">void(grpc::Status)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7d45c8fc3141d17881ac99ba0b53034" name="ac7d45c8fc3141d17881ac99ba0b53034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d45c8fc3141d17881ac99ba0b53034">&#9670;&#160;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html#afe3aab926de22d76fdb5e0d347c5d8c4">executor_type</a> &amp; <a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html">agrpc::detail::RPCExecutorBase</a>&lt; Executor &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the executor. </p>
<p>Thread-safe </p>

</div>
</div>
<a id="ac5e0d6c42c0ed62b84b90f3ce42e180a" name="ac5e0d6c42c0ed62b84b90f3ce42e180a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e0d6c42c0ed62b84b90f3ce42e180a">&#9670;&#160;</a></span>get_scheduler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html#afe3aab926de22d76fdb5e0d347c5d8c4">executor_type</a> &amp; <a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html">agrpc::detail::RPCExecutorBase</a>&lt; Executor &gt;::get_scheduler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scheduler. </p>
<p>Thread-safe</p>
<dl class="section since"><dt>Since</dt><dd>2.9.0 </dd></dl>

</div>
</div>
<a id="ade0c1cd5b69a524efbf92059fda88c1c" name="ade0c1cd5b69a524efbf92059fda88c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0c1cd5b69a524efbf92059fda88c1c">&#9670;&#160;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_context_base.html">agrpc::detail::ClientRPCContextBase</a>&lt; ResponderT&lt; RequestT, ResponseT &gt; &gt;::cancel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel this RPC. </p>
<p>Effectively calls <span class="tt"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_context_base.html#a056f94eadae189c43a6919d09e9f0031">context()</a>.TryCancel()</span>.</p>
<p>Thread-safe </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceagrpc.html">agrpc</a></li><li class="navelem"><a href="classagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4.html">ClientRPC&lt; PrepareAsyncBidiStreaming, Executor &gt;</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
