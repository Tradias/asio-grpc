<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asio-grpc: agrpc::ClientRPC&lt; PrepareAsyncBidiStreaming, Executor &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">asio-grpc<span id="projectnumber">&#160;v3.5.0</span>
   </div>
   <div id="projectbrief">Asynchronous gRPC with Asio/unified executors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">agrpc::ClientRPC&lt; PrepareAsyncBidiStreaming, Executor &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>I/O object for client-side, bidirectional-streaming rpcs.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;agrpc/client_rpc.hpp&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for agrpc::ClientRPC&lt; PrepareAsyncBidiStreaming, Executor &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4__inherit__graph.png" border="0" usemap="#aagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_inherit__map" id="aagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_inherit__map">
<area shape="rect" title="I/O object for client&#45;side, bidirectional&#45;streaming rpcs." alt="" coords="908,41,1140,81"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html" title="Bidirectional&#45;streaming ClientRPC base." alt="" coords="589,34,860,89"/>
<area shape="poly" title=" " alt="" coords="874,59,908,59,908,64,874,64"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_client_r_p_c_base.html" title=" " alt="" coords="280,34,541,89"/>
<area shape="poly" title=" " alt="" coords="555,59,589,59,589,64,555,64"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html" title="RPC&#39;s executor base." alt="" coords="22,5,215,45"/>
<area shape="poly" title=" " alt="" coords="230,36,280,43,279,48,229,42"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_client_r_p_c_context_base.html" title=" " alt="" coords="5,70,232,125"/>
<area shape="poly" title=" " alt="" coords="245,79,279,75,280,80,246,84"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for agrpc::ClientRPC&lt; PrepareAsyncBidiStreaming, Executor &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4__coll__graph.png" border="0" usemap="#aagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_coll__map" id="aagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_coll__map">
<area shape="rect" title="I/O object for client&#45;side, bidirectional&#45;streaming rpcs." alt="" coords="908,41,1140,81"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html" title="Bidirectional&#45;streaming ClientRPC base." alt="" coords="589,34,860,89"/>
<area shape="poly" title=" " alt="" coords="874,59,908,59,908,64,874,64"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_client_r_p_c_base.html" title=" " alt="" coords="280,34,541,89"/>
<area shape="poly" title=" " alt="" coords="555,59,589,59,589,64,555,64"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html" title="RPC&#39;s executor base." alt="" coords="22,5,215,45"/>
<area shape="poly" title=" " alt="" coords="230,36,280,43,279,48,229,42"/>
<area shape="rect" href="classagrpc_1_1detail_1_1_client_r_p_c_context_base.html" title=" " alt="" coords="5,70,232,125"/>
<area shape="poly" title=" " alt="" coords="245,79,279,75,280,80,246,84"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_1_1rebind__executor.html">rebind_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind the <a class="el" href="classagrpc_1_1_client_r_p_c.html" title="Primary ClientRPC template.">ClientRPC</a> to another executor.  <a href="structagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4_1_1rebind__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4ad1384caca1951c4d7b4b68b1387bb9" id="r_a4ad1384caca1951c4d7b4b68b1387bb9"><td class="memItemLeft" align="right" valign="top"><a id="a4ad1384caca1951c4d7b4b68b1387bb9" name="a4ad1384caca1951c4d7b4b68b1387bb9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Stub</b> = StubT</td></tr>
<tr class="memdesc:a4ad1384caca1951c4d7b4b68b1387bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stub type. <br /></td></tr>
<tr class="separator:a4ad1384caca1951c4d7b4b68b1387bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17fb315d9316707b442296f9096519c" id="r_ab17fb315d9316707b442296f9096519c"><td class="memItemLeft" align="right" valign="top"><a id="ab17fb315d9316707b442296f9096519c" name="ab17fb315d9316707b442296f9096519c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Request</b> = RequestT</td></tr>
<tr class="memdesc:ab17fb315d9316707b442296f9096519c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The request message type. <br /></td></tr>
<tr class="separator:ab17fb315d9316707b442296f9096519c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09949deac664f28273aa1b4f806759b1" id="r_a09949deac664f28273aa1b4f806759b1"><td class="memItemLeft" align="right" valign="top"><a id="a09949deac664f28273aa1b4f806759b1" name="a09949deac664f28273aa1b4f806759b1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Response</b> = ResponseT</td></tr>
<tr class="memdesc:a09949deac664f28273aa1b4f806759b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The response message type. <br /></td></tr>
<tr class="separator:a09949deac664f28273aa1b4f806759b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3aab926de22d76fdb5e0d347c5d8c4" id="r_afe3aab926de22d76fdb5e0d347c5d8c4"><td class="memItemLeft" align="right" valign="top"><a id="afe3aab926de22d76fdb5e0d347c5d8c4" name="afe3aab926de22d76fdb5e0d347c5d8c4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>executor_type</b> = Executor</td></tr>
<tr class="memdesc:afe3aab926de22d76fdb5e0d347c5d8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The executor type. <br /></td></tr>
<tr class="separator:afe3aab926de22d76fdb5e0d347c5d8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa30e41480cbb07e971de447834423cdd" id="r_aa30e41480cbb07e971de447834423cdd"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:aa30e41480cbb07e971de447834423cdd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa30e41480cbb07e971de447834423cdd">start</a> (StubT &amp;stub, CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:aa30e41480cbb07e971de447834423cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a bidirectional-streaming request.  <br /></td></tr>
<tr class="separator:aa30e41480cbb07e971de447834423cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6a4be476b5cab862000ba87b70e289" id="r_afb6a4be476b5cab862000ba87b70e289"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:afb6a4be476b5cab862000ba87b70e289"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#afb6a4be476b5cab862000ba87b70e289">read_initial_metadata</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:afb6a4be476b5cab862000ba87b70e289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read initial metadata.  <br /></td></tr>
<tr class="separator:afb6a4be476b5cab862000ba87b70e289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3830bd5b441d8b80c2a5dd33ae8ad2d" id="r_ad3830bd5b441d8b80c2a5dd33ae8ad2d"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:ad3830bd5b441d8b80c2a5dd33ae8ad2d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#ad3830bd5b441d8b80c2a5dd33ae8ad2d">read</a> (ResponseT &amp;response, CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:ad3830bd5b441d8b80c2a5dd33ae8ad2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message from the server.  <br /></td></tr>
<tr class="separator:ad3830bd5b441d8b80c2a5dd33ae8ad2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613e43b75d508d451dac44e474256bf8" id="r_a613e43b75d508d451dac44e474256bf8"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a613e43b75d508d451dac44e474256bf8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a613e43b75d508d451dac44e474256bf8">write</a> (const RequestT &amp;request, grpc::WriteOptions options, CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a613e43b75d508d451dac44e474256bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the server.  <br /></td></tr>
<tr class="separator:a613e43b75d508d451dac44e474256bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7617653d30c2f57cdaeffcefed89793f" id="r_a7617653d30c2f57cdaeffcefed89793f"><td class="memTemplParams" colspan="2"><a id="a7617653d30c2f57cdaeffcefed89793f" name="a7617653d30c2f57cdaeffcefed89793f"></a>
template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a7617653d30c2f57cdaeffcefed89793f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>write</b> (const RequestT &amp;request, CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a7617653d30c2f57cdaeffcefed89793f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the server (default WriteOptions) <br /></td></tr>
<tr class="separator:a7617653d30c2f57cdaeffcefed89793f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d19b1441bd69861873989f76f5875e2" id="r_a2d19b1441bd69861873989f76f5875e2"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a2d19b1441bd69861873989f76f5875e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a2d19b1441bd69861873989f76f5875e2">writes_done</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a2d19b1441bd69861873989f76f5875e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal writes done to the server.  <br /></td></tr>
<tr class="separator:a2d19b1441bd69861873989f76f5875e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9b990891472214354e3425616f7b23" id="r_a9a9b990891472214354e3425616f7b23"><td class="memTemplParams" colspan="2">template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a9a9b990891472214354e3425616f7b23"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a9a9b990891472214354e3425616f7b23">finish</a> (CompletionToken &amp;&amp;token=CompletionToken{})</td></tr>
<tr class="memdesc:a9a9b990891472214354e3425616f7b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal writes done and finish the rpc.  <br /></td></tr>
<tr class="separator:a9a9b990891472214354e3425616f7b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d45c8fc3141d17881ac99ba0b53034" id="r_ac7d45c8fc3141d17881ac99ba0b53034"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html#afe3aab926de22d76fdb5e0d347c5d8c4">executor_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html#ac7d45c8fc3141d17881ac99ba0b53034">get_executor</a> () const noexcept</td></tr>
<tr class="memdesc:ac7d45c8fc3141d17881ac99ba0b53034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the executor.  <br /></td></tr>
<tr class="separator:ac7d45c8fc3141d17881ac99ba0b53034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e0d6c42c0ed62b84b90f3ce42e180a" id="r_ac5e0d6c42c0ed62b84b90f3ce42e180a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html#afe3aab926de22d76fdb5e0d347c5d8c4">executor_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html#ac5e0d6c42c0ed62b84b90f3ce42e180a">get_scheduler</a> () const noexcept</td></tr>
<tr class="memdesc:ac5e0d6c42c0ed62b84b90f3ce42e180a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scheduler.  <br /></td></tr>
<tr class="separator:ac5e0d6c42c0ed62b84b90f3ce42e180a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056f94eadae189c43a6919d09e9f0031" id="r_a056f94eadae189c43a6919d09e9f0031"><td class="memItemLeft" align="right" valign="top"><a id="a056f94eadae189c43a6919d09e9f0031" name="a056f94eadae189c43a6919d09e9f0031"></a>
grpc::ClientContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>context</b> ()</td></tr>
<tr class="memdesc:a056f94eadae189c43a6919d09e9f0031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying <code>grpc::ClientContext</code> <br /></td></tr>
<tr class="separator:a056f94eadae189c43a6919d09e9f0031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5602cbb3e4c886c89405ad0404626e64" id="r_a5602cbb3e4c886c89405ad0404626e64"><td class="memItemLeft" align="right" valign="top"><a id="a5602cbb3e4c886c89405ad0404626e64" name="a5602cbb3e4c886c89405ad0404626e64"></a>
const grpc::ClientContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>context</b> () const</td></tr>
<tr class="memdesc:a5602cbb3e4c886c89405ad0404626e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying <code>grpc::ClientContext</code> (const overload) <br /></td></tr>
<tr class="separator:a5602cbb3e4c886c89405ad0404626e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0c1cd5b69a524efbf92059fda88c1c" id="r_ade0c1cd5b69a524efbf92059fda88c1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_context_base.html#ade0c1cd5b69a524efbf92059fda88c1c">cancel</a> () noexcept</td></tr>
<tr class="memdesc:ade0c1cd5b69a524efbf92059fda88c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel this RPC.  <br /></td></tr>
<tr class="separator:ade0c1cd5b69a524efbf92059fda88c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a07458f85b4281c361b16f652b6cda493" id="r_a07458f85b4281c361b16f652b6cda493"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07458f85b4281c361b16f652b6cda493">service_name</a> () noexcept</td></tr>
<tr class="memdesc:a07458f85b4281c361b16f652b6cda493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the gRPC service.  <br /></td></tr>
<tr class="separator:a07458f85b4281c361b16f652b6cda493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e96b31ad3ef1098a4c8c23e9dd94b7" id="r_a36e96b31ad3ef1098a4c8c23e9dd94b7"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36e96b31ad3ef1098a4c8c23e9dd94b7">method_name</a> () noexcept</td></tr>
<tr class="memdesc:a36e96b31ad3ef1098a4c8c23e9dd94b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the gRPC method.  <br /></td></tr>
<tr class="separator:a36e96b31ad3ef1098a4c8c23e9dd94b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0b85df8344986b161b6223aa80595a6c" id="r_a0b85df8344986b161b6223aa80595a6c"><td class="memItemLeft" align="right" valign="top"><a id="a0b85df8344986b161b6223aa80595a6c" name="a0b85df8344986b161b6223aa80595a6c"></a>
static constexpr <a class="el" href="namespaceagrpc.html#a42c57be5049212df6909b6da0c60d36e">agrpc::ClientRPCType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TYPE</b> = <a class="el" href="namespaceagrpc.html#a42c57be5049212df6909b6da0c60d36eaf92e0d805b776fa75c63d16707f99111">agrpc::ClientRPCType::BIDIRECTIONAL_STREAMING</a></td></tr>
<tr class="memdesc:a0b85df8344986b161b6223aa80595a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rpc type. <br /></td></tr>
<tr class="separator:a0b85df8344986b161b6223aa80595a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class StubT, class RequestT, class ResponseT, template&lt; class, class &gt; class ResponderT, detail::PrepareAsyncClientBidirectionalStreamingRequest&lt; StubT, ResponderT&lt; RequestT, ResponseT &gt; &gt; PrepareAsyncBidiStreaming, class Executor&gt;<br />
class agrpc::ClientRPC&lt; PrepareAsyncBidiStreaming, Executor &gt;</div><p>I/O object for client-side, bidirectional-streaming rpcs. </p>
<p>Example:</p>
<div class="fragment"><div class="line">asio::awaitable&lt;void&gt; client_rpc_bidirectional_streaming(<a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a>&amp; grpc_context,</div>
<div class="line">                                                         example::v1::Example::Stub&amp; stub)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>RPC =</div>
<div class="line">        <a class="code hl_class" href="classagrpc_1_1_client_r_p_c.html">agrpc::ClientRPC&lt;&amp;example::v1::Example::Stub::PrepareAsyncBidirectionalStreaming&gt;</a>;</div>
<div class="line"> </div>
<div class="line">    RPC rpc{grpc_context};</div>
<div class="line">    rpc.context().set_deadline(std::chrono::system_clock::now() +</div>
<div class="line">                               std::chrono::seconds(5));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!<span class="keyword">co_await</span> rpc.start(stub))</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> grpc::Status status = <span class="keyword">co_await</span> rpc.finish();</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Rpc failed: &quot;</span> &lt;&lt; status.error_message();</div>
<div class="line">        <span class="keyword">co_return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    RPC::Request request;</div>
<div class="line">    request.set_integer(42);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> write_ok{<span class="keyword">true</span>};</div>
<div class="line">    RPC::Response response;</div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">co_await</span> rpc.read(response) &amp;&amp; write_ok)</div>
<div class="line">    {</div>
<div class="line">        request.set_integer(response.integer() + 1);</div>
<div class="line">        write_ok = <span class="keyword">co_await</span> rpc.write(request);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> grpc::Status status = <span class="keyword">co_await</span> rpc.finish();</div>
<div class="line">    <span class="keywordflow">if</span> (!status.ok())</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Rpc failed: &quot;</span> &lt;&lt; status.error_message();</div>
<div class="line">        <span class="keyword">co_return</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Based on <code>.proto</code> file:</p>
<div class="fragment"><div class="line">syntax = &quot;proto3&quot;;</div>
<div class="line"> </div>
<div class="line">package example.v1;</div>
<div class="line"> </div>
<div class="line">service Example {</div>
<div class="line">  rpc ServerStreaming(Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc ClientStreaming(stream Request) returns (Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc BidirectionalStreaming(stream Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc Unary(Request) returns (Response) {}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Request {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Response {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PrepareAsyncBidiStreaming</td><td>A pointer to the generated, async version of the gRPC method. The async version starts with <code>PrepareAsync</code>. </td></tr>
    <tr><td class="paramname">Executor</td><td>The executor type, must be capable of referring to a <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Per-Operation Cancellation</b></p>
<p>Terminal and partial. Cancellation is performed by invoking <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_client_context.html#abd0f6715c30287b75288015eee628984">grpc::ClientContext::TryCancel</a>. After successful cancellation no further operations may be started on the rpc (except <a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a9a9b990891472214354e3425616f7b23" title="Signal writes done and finish the rpc.">finish()</a>). Operations are also cancelled when the deadline of the rpc has been reached (see <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_client_context.html#ad4e16866fee3f6ee5a10efb5be6f4da6">grpc::ClientContext::set_deadline</a>).</p>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a07458f85b4281c361b16f652b6cda493" name="a07458f85b4281c361b16f652b6cda493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07458f85b4281c361b16f652b6cda493">&#9670;&#160;</a></span>service_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StubT , class RequestT , class ResponseT , template&lt; class, class &gt; class ResponderT, detail::PrepareAsyncClientBidirectionalStreamingRequest&lt; StubT, ResponderT&lt; RequestT, ResponseT &gt; &gt; PrepareAsyncBidiStreaming, class Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::string_view <a class="el" href="classagrpc_1_1_client_r_p_c.html">agrpc::ClientRPC</a>&lt; PrepareAsyncBidiStreaming, Executor &gt;::service_name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of the gRPC service. </p>
<p>Equal to the generated <code>Service::service_full_name()</code>.</p>
<p>E.g. for the <code>.proto</code> schema</p>
<div class="fragment"><div class="line">package example.v1;</div>
<div class="line"> </div>
<div class="line">service Example { ... }</div>
</div><!-- fragment --><p>the return value would be <code>"example.v1.Example"</code>.</p>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="a36e96b31ad3ef1098a4c8c23e9dd94b7" name="a36e96b31ad3ef1098a4c8c23e9dd94b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e96b31ad3ef1098a4c8c23e9dd94b7">&#9670;&#160;</a></span>method_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StubT , class RequestT , class ResponseT , template&lt; class, class &gt; class ResponderT, detail::PrepareAsyncClientBidirectionalStreamingRequest&lt; StubT, ResponderT&lt; RequestT, ResponseT &gt; &gt; PrepareAsyncBidiStreaming, class Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::string_view <a class="el" href="classagrpc_1_1_client_r_p_c.html">agrpc::ClientRPC</a>&lt; PrepareAsyncBidiStreaming, Executor &gt;::method_name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of the gRPC method. </p>
<p>E.g. for <code><a class="el" href="classagrpc_1_1_client_r_p_c.html" title="Primary ClientRPC template.">agrpc::ClientRPC</a>&lt;&amp;example::Example::Stub::PrepareAsyncMyMethod&gt;</code> the return value would be <code>"MyMethod"</code>.</p>
<dl class="section since"><dt>Since</dt><dd>2.6.0 </dd></dl>

</div>
</div>
<a id="aa30e41480cbb07e971de447834423cdd" name="aa30e41480cbb07e971de447834423cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30e41480cbb07e971de447834423cdd">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StubT , class RequestT , class ResponseT , template&lt; class, class &gt; class ResponderT, detail::PrepareAsyncClientBidirectionalStreamingRequest&lt; StubT, ResponderT&lt; RequestT, ResponseT &gt; &gt; PrepareAsyncBidiStreaming, class Executor &gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classagrpc_1_1_client_r_p_c.html">agrpc::ClientRPC</a>&lt; PrepareAsyncBidiStreaming, Executor &gt;::start </td>
          <td>(</td>
          <td class="paramtype">StubT &amp;</td>          <td class="paramname"><span class="paramname"><em>stub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a bidirectional-streaming request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stub</td><td>The Stub that corresponds to the gRPC method. </td></tr>
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or <code><a class="el" href="namespaceagrpc.html#aa9c38be6a3d7d59a78007bc4fff311a4" title="Instance and factory for sender completion tokens.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. <code>true</code> means that the rpc was started successfully. If it is <code>false</code>, then call <code><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a9a9b990891472214354e3425616f7b23" title="Signal writes done and finish the rpc.">finish()</a></code> to obtain error details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb6a4be476b5cab862000ba87b70e289" name="afb6a4be476b5cab862000ba87b70e289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6a4be476b5cab862000ba87b70e289">&#9670;&#160;</a></span>read_initial_metadata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RequestT , class ResponseT , template&lt; class, class &gt; class ResponderT, class Executor &gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::ClientRPCBidiStreamingBase&lt; ResponderT&lt; RequestT, ResponseT &gt;, Executor &gt;::read_initial_metadata </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read initial metadata. </p>
<p>Request notification of the reading of the initial metadata.</p>
<p>This call is optional.</p>
<p>Side effect:</p>
<ul>
<li>Upon receiving initial metadata from the server, the ClientContext associated with this call is updated, and the calling code can access the received metadata through the ClientContext.</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>If the server does not explicitly send initial metadata (e.g. by calling send_initial_metadata()) but waits for a message from the client instead then this function won't complete until <code><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a613e43b75d508d451dac44e474256bf8" title="Send a message to the server.">write()</a></code> is called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or <code><a class="el" href="namespaceagrpc.html#aa9c38be6a3d7d59a78007bc4fff311a4" title="Instance and factory for sender completion tokens.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. <code>true</code> indicates that the metadata was read. If it is <code>false</code>, then the call is dead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3830bd5b441d8b80c2a5dd33ae8ad2d" name="ad3830bd5b441d8b80c2a5dd33ae8ad2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3830bd5b441d8b80c2a5dd33ae8ad2d">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RequestT , class ResponseT , template&lt; class, class &gt; class ResponderT, class Executor &gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::ClientRPCBidiStreamingBase&lt; ResponderT&lt; RequestT, ResponseT &gt;, Executor &gt;::read </td>
          <td>(</td>
          <td class="paramtype">ResponseT &amp;</td>          <td class="paramname"><span class="paramname"><em>response</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive a message from the server. </p>
<p>This is thread-safe with respect to <code><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a613e43b75d508d451dac44e474256bf8" title="Send a message to the server.">write()</a></code> or <code><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a2d19b1441bd69861873989f76f5875e2" title="Signal writes done to the server.">writes_done()</a></code> methods. It should not be called concurrently with other operations. It is not meaningful to call it concurrently with another read on the same stream since reads on the same stream are delivered in order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or <code><a class="el" href="namespaceagrpc.html#aa9c38be6a3d7d59a78007bc4fff311a4" title="Instance and factory for sender completion tokens.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. <code>true</code> indicates that a valid message was read. <code>false</code> when there will be no more incoming messages, either because the other server is finished sending messages or the stream has failed (or been cancelled). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a613e43b75d508d451dac44e474256bf8" name="a613e43b75d508d451dac44e474256bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613e43b75d508d451dac44e474256bf8">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RequestT , class ResponseT , template&lt; class, class &gt; class ResponderT, class Executor &gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::ClientRPCBidiStreamingBase&lt; ResponderT&lt; RequestT, ResponseT &gt;, Executor &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const RequestT &amp;</td>          <td class="paramname"><span class="paramname"><em>request</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">grpc::WriteOptions</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message to the server. </p>
<p>Only one write may be outstanding at any given time. This is thread-safe with respect to <code><a class="el" href="namespaceagrpc.html#a685510388ab87c9a90c44f880e9de9cd" title="Read from a streaming RPC.">read()</a></code>. It should not be called concurrently with other operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request message, save to delete when this function returns, unless a deferred completion token is used like <code><a class="el" href="namespaceagrpc.html#aa9c38be6a3d7d59a78007bc4fff311a4" title="Instance and factory for sender completion tokens.">agrpc::use_sender</a></code> or <code>asio::deferred</code>. </td></tr>
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or <code><a class="el" href="namespaceagrpc.html#aa9c38be6a3d7d59a78007bc4fff311a4" title="Instance and factory for sender completion tokens.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. <code>true</code> means that the data is going to go to the wire. If it is <code>false</code>, it is not going to the wire because the call is already dead (i.e., canceled, deadline expired, other side dropped the channel, etc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d19b1441bd69861873989f76f5875e2" name="a2d19b1441bd69861873989f76f5875e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d19b1441bd69861873989f76f5875e2">&#9670;&#160;</a></span>writes_done()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RequestT , class ResponseT , template&lt; class, class &gt; class ResponderT, class Executor &gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::ClientRPCBidiStreamingBase&lt; ResponderT&lt; RequestT, ResponseT &gt;, Executor &gt;::writes_done </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal writes done to the server. </p>
<p>May only be called once. Should not be called after performing a write with the <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_write_options.html#ad930c28f5c32832e1d48ee30bf0858e3">set_last_message</a> option.</p>
<p>Signal the client is done with the writes (half-close the client stream). Thread-safe with respect to read. May not be called concurrently with a <code><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_bidi_streaming_base_3_01_responder_t_3_01_request_t_00_01_ee3885a4767d154ee2c386c451f018bf.html#a613e43b75d508d451dac44e474256bf8" title="Send a message to the server.">write()</a></code> that has the <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_write_options.html#ad930c28f5c32832e1d48ee30bf0858e3">set_last_message</a> option set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or <code><a class="el" href="namespaceagrpc.html#aa9c38be6a3d7d59a78007bc4fff311a4" title="Instance and factory for sender completion tokens.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. <code>true</code> means that the data is going to go to the wire. If it is <code>false</code>, it is not going to the wire because the call is already dead (i.e., canceled, deadline expired, other side dropped the channel, etc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a9b990891472214354e3425616f7b23" name="a9a9b990891472214354e3425616f7b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9b990891472214354e3425616f7b23">&#9670;&#160;</a></span>finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RequestT , class ResponseT , template&lt; class, class &gt; class ResponderT, class Executor &gt; </div>
<div class="memtemplate">
template&lt;class CompletionToken  = detail::DefaultCompletionTokenT&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::ClientRPCBidiStreamingBase&lt; ResponderT&lt; RequestT, ResponseT &gt;, Executor &gt;::finish </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CompletionToken{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal writes done and finish the rpc. </p>
<p>Indicate that the stream is to be finished and request notification for when the call has been ended.</p>
<p>May not be used concurrently with other operations and may only be called once.</p>
<p>It is appropriate to call this method when:</p>
<ul>
<li>All messages from the server have been received (either known implictly, or explicitly because a previous read operation returned <code>false</code>).</li>
</ul>
<p>The operation will finish when either:</p>
<ul>
<li>The server has returned a status. </li>
<li>The call failed for some reason and the library generated a status.</li>
</ul>
<p>Note that implementations of this method attempt to receive initial metadata from the server if initial metadata has not been received yet.</p>
<p>Side effect:</p>
<ul>
<li>The ClientContext associated with the call is updated with possible initial and trailing metadata received from the server.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or <code><a class="el" href="namespaceagrpc.html#aa9c38be6a3d7d59a78007bc4fff311a4" title="Instance and factory for sender completion tokens.">agrpc::use_sender</a></code>. The completion signature is <code>void(grpc::Status)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7d45c8fc3141d17881ac99ba0b53034" name="ac7d45c8fc3141d17881ac99ba0b53034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d45c8fc3141d17881ac99ba0b53034">&#9670;&#160;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html#afe3aab926de22d76fdb5e0d347c5d8c4">executor_type</a> &amp; <a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html">agrpc::detail::RPCExecutorBase</a>&lt; Executor &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the executor. </p>
<p>Thread-safe </p>

</div>
</div>
<a id="ac5e0d6c42c0ed62b84b90f3ce42e180a" name="ac5e0d6c42c0ed62b84b90f3ce42e180a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e0d6c42c0ed62b84b90f3ce42e180a">&#9670;&#160;</a></span>get_scheduler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html#afe3aab926de22d76fdb5e0d347c5d8c4">executor_type</a> &amp; <a class="el" href="classagrpc_1_1detail_1_1_r_p_c_executor_base.html">agrpc::detail::RPCExecutorBase</a>&lt; Executor &gt;::get_scheduler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scheduler. </p>
<p>Thread-safe</p>
<dl class="section since"><dt>Since</dt><dd>2.9.0 </dd></dl>

</div>
</div>
<a id="ade0c1cd5b69a524efbf92059fda88c1c" name="ade0c1cd5b69a524efbf92059fda88c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0c1cd5b69a524efbf92059fda88c1c">&#9670;&#160;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_context_base.html">agrpc::detail::ClientRPCContextBase</a>&lt; ResponderT&lt; RequestT, ResponseT &gt; &gt;::cancel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel this RPC. </p>
<p>Effectively calls <code><a class="el" href="classagrpc_1_1detail_1_1_client_r_p_c_context_base.html#a056f94eadae189c43a6919d09e9f0031">context()</a>.TryCancel()</code>.</p>
<p>Thread-safe </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceagrpc.html">agrpc</a></li><li class="navelem"><a class="el" href="classagrpc_1_1_client_r_p_c_3_01_prepare_async_bidi_streaming_00_01_executor_01_4.html">ClientRPC&lt; PrepareAsyncBidiStreaming, Executor &gt;</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
