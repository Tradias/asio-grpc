<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asio-grpc: agrpc::detail::RepeatedlyRequestFn Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">asio-grpc<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">Asynchronous gRPC using Boost.Asio&#39;s executor model</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classagrpc_1_1detail_1_1_repeatedly_request_fn.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classagrpc_1_1detail_1_1_repeatedly_request_fn-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">agrpc::detail::RepeatedlyRequestFn Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Server-side function object to register request handlers.  
 <a href="classagrpc_1_1detail_1_1_repeatedly_request_fn.html#details">More...</a></p>

<p><code>#include &lt;agrpc/repeatedlyRequest.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5b2141397745975b58a944218386f8b5"><td class="memTemplParams" colspan="2"><a id="a5b2141397745975b58a944218386f8b5" name="a5b2141397745975b58a944218386f8b5"></a>
template&lt;class RPC , class Service , class Request , class Responder , class RequestHandler , class CompletionToken  = detail::NoOp&gt; </td></tr>
<tr class="memitem:a5b2141397745975b58a944218386f8b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator()</b> (detail::ServerMultiArgRequest&lt; RPC, Request, Responder &gt; rpc, Service &amp;service, RequestHandler &amp;&amp;request_handler, CompletionToken &amp;&amp;token={}) const</td></tr>
<tr class="memdesc:a5b2141397745975b58a944218386f8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for unary and server-streaming RPCs. <br /></td></tr>
<tr class="separator:a5b2141397745975b58a944218386f8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ab137b91769cc566f31584d4cc97f8"><td class="memTemplParams" colspan="2"><a id="a98ab137b91769cc566f31584d4cc97f8" name="a98ab137b91769cc566f31584d4cc97f8"></a>
template&lt;class RPC , class Service , class Responder , class RequestHandler , class CompletionToken  = detail::NoOp&gt; </td></tr>
<tr class="memitem:a98ab137b91769cc566f31584d4cc97f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator()</b> (detail::ServerSingleArgRequest&lt; RPC, Responder &gt; rpc, Service &amp;service, RequestHandler &amp;&amp;request_handler, CompletionToken &amp;&amp;token={}) const</td></tr>
<tr class="memdesc:a98ab137b91769cc566f31584d4cc97f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for client-streaming and bidirectional RPCs. <br /></td></tr>
<tr class="separator:a98ab137b91769cc566f31584d4cc97f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Server-side function object to register request handlers. </p>
<p >The examples below are based on the following .proto file:</p>
<div class="fragment"><div class="line">syntax = &quot;proto3&quot;;</div>
<div class="line"> </div>
<div class="line">package example.v1;</div>
<div class="line"> </div>
<div class="line">import &quot;google/protobuf/empty.proto&quot;;</div>
<div class="line"> </div>
<div class="line">service Example {</div>
<div class="line">  rpc ServerStreaming(Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc ClientStreaming(stream Request) returns (Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc BidirectionalStreaming(stream Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc Unary(Request) returns (Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc SlowUnary(Request) returns (Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc Shutdown(google.protobuf.Empty) returns (google.protobuf.Empty) {}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Request {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Response {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p >This function helps to ensure that there are enough outstanding calls to <code>request</code> to match incoming RPCs. It takes a RPC, a Service, a RequestHandler and a CompletionToken. The RequestHandler determines what to do with a client request, it could e.g. spawn a new coroutine to process it. It must also have an associated executor that refers to a <code><a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">agrpc::GrpcContext</a></code>. When the client makes a request the RequestHandler is invoked with a <code><a class="el" href="classagrpc_1_1_repeatedly_request_context.html" title="Context passed to the request handler of repeatedly_request.">agrpc::RepeatedlyRequestContext</a></code> - a move-only type that provides a stable address to the <code>grpc::ServerContext</code>, the request (if any) and the responder that were used when requesting the RPC. It should be kept alive until the RPC is finished. The RequestHandler or its associated executor may also have an associated allocator to control the allocation needed for each request.</p>
<p ><code><a class="el" href="namespaceagrpc.html#ace37792785c92502711e61d9e9a5ff2d" title="Register a request handler for a RPC.">agrpc::repeatedly_request</a></code> will complete when it was cancelled, the <code><a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">agrpc::GrpcContext</a></code> was stopped or the <code>grpc::Server</code> been shutdown. It will <b>not</b> wait until all outstanding RPCs that are being processed by the RequestHandler have completed.</p>
<p >When using the special CompletionToken created by <code><a class="el" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9" title="Create sender completion token.">agrpc::use_sender</a></code> the RequestHandler's signature must be:<br  />
 <code>sender auto operator()(grpc::ServerContext&amp;, Request&amp;, Responder&amp;)</code> for unary and server-streaming requests and<br  />
 <code>sender auto operator()(grpc::ServerContext&amp;, Responder&amp;)</code> otherwise.<br  />
 For libunifex this is the only available overload of this function.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> register_client_streaming_handler(example::v1::Example::AsyncService&amp; service, <a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a>&amp; grpc_context)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_variable" href="namespaceagrpc.html#ace37792785c92502711e61d9e9a5ff2d">agrpc::repeatedly_request</a>(</div>
<div class="line">        &amp;example::v1::Example::AsyncService::RequestUnary, service,</div>
<div class="line">        [&amp;](grpc::ServerContext&amp;, example::v1::Request&amp; <a class="code hl_variable" href="namespaceagrpc.html#a4a11653afb11f9486e4e3db0136a3e08">request</a>,</div>
<div class="line">            grpc::ServerAsyncResponseWriter&lt;example::v1::Response&gt;&amp; writer)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> unifex::let_value(unifex::just(example::v1::Response{}),</div>
<div class="line">                                     [&amp;](<span class="keyword">auto</span>&amp; response)</div>
<div class="line">                                     {</div>
<div class="line">                                         response.set_integer(<a class="code hl_variable" href="namespaceagrpc.html#a4a11653afb11f9486e4e3db0136a3e08">request</a>.integer());</div>
<div class="line">                                         <span class="keywordflow">return</span> <a class="code hl_variable" href="namespaceagrpc.html#a88b9f806c77bb8077f3f7973beede2d0">agrpc::finish</a>(writer, response, grpc::Status::OK,</div>
<div class="line">                                                              <a class="code hl_variable" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9">agrpc::use_sender</a>(grpc_context));</div>
<div class="line">                                     });</div>
<div class="line">        },</div>
<div class="line">        <a class="code hl_variable" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9">agrpc::use_sender</a>(grpc_context));</div>
<div class="line">}</div>
<div class="ttc" id="aclassagrpc_1_1_grpc_context_html"><div class="ttname"><a href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a></div><div class="ttdoc">Execution context based on grpc::CompletionQueue</div><div class="ttdef"><b>Definition:</b> grpcContext.hpp:50</div></div>
<div class="ttc" id="anamespaceagrpc_html_a35d42ccb3fa5adce6b5c045a275dafa9"><div class="ttname"><a href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9">agrpc::use_sender</a></div><div class="ttdeci">constexpr detail::UseSenderFn use_sender</div><div class="ttdoc">Create sender completion token.</div><div class="ttdef"><b>Definition:</b> useSender.hpp:89</div></div>
<div class="ttc" id="anamespaceagrpc_html_a4a11653afb11f9486e4e3db0136a3e08"><div class="ttname"><a href="namespaceagrpc.html#a4a11653afb11f9486e4e3db0136a3e08">agrpc::request</a></div><div class="ttdeci">constexpr detail::RequestFn request</div><div class="ttdoc">Start a new RPC.</div><div class="ttdef"><b>Definition:</b> rpc.hpp:1378</div></div>
<div class="ttc" id="anamespaceagrpc_html_a88b9f806c77bb8077f3f7973beede2d0"><div class="ttname"><a href="namespaceagrpc.html#a88b9f806c77bb8077f3f7973beede2d0">agrpc::finish</a></div><div class="ttdeci">constexpr detail::FinishFn finish</div><div class="ttdoc">Finish a RPC.</div><div class="ttdef"><b>Definition:</b> rpc.hpp:1414</div></div>
<div class="ttc" id="anamespaceagrpc_html_ace37792785c92502711e61d9e9a5ff2d"><div class="ttname"><a href="namespaceagrpc.html#ace37792785c92502711e61d9e9a5ff2d">agrpc::repeatedly_request</a></div><div class="ttdeci">constexpr detail::RepeatedlyRequestFn repeatedly_request</div><div class="ttdoc">Register a request handler for a RPC.</div><div class="ttdef"><b>Definition:</b> repeatedlyRequest.hpp:140</div></div>
</div><!-- fragment --><p >Another special overload of <code><a class="el" href="namespaceagrpc.html#ace37792785c92502711e61d9e9a5ff2d" title="Register a request handler for a RPC.">agrpc::repeatedly_request</a></code> can be used by passing a RequestHandler with the following signature:<br  />
 <code>awaitable auto operator()(grpc::ServerContext&amp;, Request&amp;, Responder&amp;)</code> for unary and server-streaming requests and<br  />
 <code>awaitable auto operator()(grpc::ServerContext&amp;, Responder&amp;)</code> otherwise.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> register_client_streaming_handler(example::v1::Example::AsyncService&amp; service, <a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a>&amp; grpc_context)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_variable" href="namespaceagrpc.html#ace37792785c92502711e61d9e9a5ff2d">agrpc::repeatedly_request</a>(</div>
<div class="line">        &amp;example::v1::Example::AsyncService::RequestClientStreaming, service,</div>
<div class="line">        asio::bind_executor(</div>
<div class="line">            grpc_context,</div>
<div class="line">            [&amp;](grpc::ServerContext&amp;,</div>
<div class="line">                grpc::ServerAsyncReader&lt;example::v1::Response, example::v1::Request&gt;&amp;) -&gt; asio::awaitable&lt;void&gt;</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// ...</span></div>
<div class="line">                <span class="keyword">co_return</span>;</div>
<div class="line">            }));</div>
<div class="line">}</div>
</div><!-- fragment --><p >The following example shows how to implement a RequestHandler with a custom allocator for simple, high-performance RPC processing:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Executor, <span class="keyword">class</span> Handler&gt;</div>
<div class="line"><span class="keyword">struct </span>AssociatedHandler</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> executor_type = Executor;</div>
<div class="line"> </div>
<div class="line">    Executor executor;</div>
<div class="line">    Handler handler;</div>
<div class="line"> </div>
<div class="line">    AssociatedHandler(Executor executor, Handler handler) : executor(std::move(executor)), handler(std::move(handler))</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classagrpc_1_1detail_1_1_repeatedly_request_fn.html#a5b2141397745975b58a944218386f8b5">operator()</a>(<a class="code hl_class" href="classagrpc_1_1_repeatedly_request_context.html">agrpc::RepeatedlyRequestContext&lt;T&gt;</a>&amp;&amp; request_context)</div>
<div class="line">    {</div>
<div class="line">        std::invoke(handler, std::move(request_context), executor);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] executor_type get_executor() const noexcept { <span class="keywordflow">return</span> executor; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> repeatedly_request_example(example::v1::Example::AsyncService&amp; service, <a class="code hl_class" href="classagrpc_1_1_grpc_context.html">agrpc::GrpcContext</a>&amp; grpc_context)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_variable" href="namespaceagrpc.html#ace37792785c92502711e61d9e9a5ff2d">agrpc::repeatedly_request</a>(</div>
<div class="line">        &amp;example::v1::Example::AsyncService::RequestUnary, service,</div>
<div class="line">        AssociatedHandler{</div>
<div class="line">            asio::require(grpc_context.<a class="code hl_function" href="classagrpc_1_1_grpc_context.html#ab82f48f7e09542f242b683cda49aa6a9">get_executor</a>(), asio::execution::allocator(grpc_context.<a class="code hl_function" href="classagrpc_1_1_grpc_context.html#ab38d929d30e72aface90b3d429727d33">get_allocator</a>())),</div>
<div class="line">            [](<span class="keyword">auto</span>&amp;&amp; request_context, <span class="keyword">auto</span>&amp;&amp; executor)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">auto</span>&amp; writer = request_context.responder();</div>
<div class="line">                example::v1::Response response;</div>
<div class="line">                <a class="code hl_variable" href="namespaceagrpc.html#a88b9f806c77bb8077f3f7973beede2d0">agrpc::finish</a>(writer, response, grpc::Status::OK,</div>
<div class="line">                              asio::bind_executor(executor, [c = std::move(request_context)](<span class="keywordtype">bool</span>) {}));</div>
<div class="line">            }});</div>
<div class="line">}</div>
<div class="ttc" id="aclassagrpc_1_1_grpc_context_html_ab38d929d30e72aface90b3d429727d33"><div class="ttname"><a href="classagrpc_1_1_grpc_context.html#ab38d929d30e72aface90b3d429727d33">agrpc::GrpcContext::get_allocator</a></div><div class="ttdeci">allocator_type get_allocator() noexcept</div><div class="ttdoc">Get the associated allocator.</div><div class="ttdef"><b>Definition:</b> grpcContext.ipp:126</div></div>
<div class="ttc" id="aclassagrpc_1_1_grpc_context_html_ab82f48f7e09542f242b683cda49aa6a9"><div class="ttname"><a href="classagrpc_1_1_grpc_context.html#ab82f48f7e09542f242b683cda49aa6a9">agrpc::GrpcContext::get_executor</a></div><div class="ttdeci">executor_type get_executor() noexcept</div><div class="ttdoc">Get the associated executor.</div><div class="ttdef"><b>Definition:</b> grpcContext.ipp:122</div></div>
<div class="ttc" id="aclassagrpc_1_1_repeatedly_request_context_html"><div class="ttname"><a href="classagrpc_1_1_repeatedly_request_context.html">agrpc::RepeatedlyRequestContext</a></div><div class="ttdoc">Context passed to the request handler of repeatedly_request.</div><div class="ttdef"><b>Definition:</b> repeatedlyRequestContext.hpp:41</div></div>
<div class="ttc" id="aclassagrpc_1_1detail_1_1_repeatedly_request_fn_html_a5b2141397745975b58a944218386f8b5"><div class="ttname"><a href="classagrpc_1_1detail_1_1_repeatedly_request_fn.html#a5b2141397745975b58a944218386f8b5">agrpc::detail::RepeatedlyRequestFn::operator()</a></div><div class="ttdeci">auto operator()(detail::ServerMultiArgRequest&lt; RPC, Request, Responder &gt; rpc, Service &amp;service, RequestHandler &amp;&amp;request_handler, CompletionToken &amp;&amp;token={}) const</div><div class="ttdoc">Overload for unary and server-streaming RPCs.</div><div class="ttdef"><b>Definition:</b> repeatedlyRequest.hpp:113</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request_handler</td><td>Any exception thrown by the invocation of the request handler will be rethrown by <a class="el" href="classagrpc_1_1_grpc_context.html#ac287c8b9a86af915575be9807342bbf3" title="Run the grpc::CompletionQueue">GrpcContext::run()</a>. Except for the sender version, where the exception will be send to the receiver. </td></tr>
    <tr><td class="paramname">token</td><td>The completion signature is <code>void()</code>. If the token has been created by <code><a class="el" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9" title="Create sender completion token.">agrpc::use_sender</a></code> then the request handler must return a sender. </td></tr>
  </table>
  </dd>
</dl>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>src/agrpc/repeatedlyRequest.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceagrpc.html">agrpc</a></li><li class="navelem"><b>detail</b></li><li class="navelem"><a class="el" href="classagrpc_1_1detail_1_1_repeatedly_request_fn.html">RepeatedlyRequestFn</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
