<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="light-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asio-grpc: agrpc::detail::FinishFn Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">asio-grpc<span id="projectnumber">&#160;v1.6.0</span>
   </div>
   <div id="projectbrief">Asynchronous gRPC with Asio/unified executors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structagrpc_1_1detail_1_1_finish_fn.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structagrpc_1_1detail_1_1_finish_fn-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">agrpc::detail::FinishFn Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Client and server-side function object to finish RPCs.  
 <a href="structagrpc_1_1detail_1_1_finish_fn.html#details">More...</a></p>

<p><code>#include &lt;agrpc/rpc.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a613201161863f8ccea494e1c560c56ea"><td class="memTemplParams" colspan="2">template&lt;class Response , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </td></tr>
<tr class="memitem:a613201161863f8ccea494e1c560c56ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structagrpc_1_1detail_1_1_finish_fn.html#a613201161863f8ccea494e1c560c56ea">operator()</a> (grpc::ServerAsyncWriter&lt; Response &gt; &amp;writer, const grpc::Status &amp;status, CompletionToken &amp;&amp;token={}) const noexcept(detail::IS_NOTRHOW_GRPC_INITIATE_COMPLETION_TOKEN&lt; CompletionToken &gt;)</td></tr>
<tr class="memdesc:a613201161863f8ccea494e1c560c56ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish a server stream (server-side)  <a href="structagrpc_1_1detail_1_1_finish_fn.html#a613201161863f8ccea494e1c560c56ea">More...</a><br /></td></tr>
<tr class="separator:a613201161863f8ccea494e1c560c56ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e8c3b3feb46544e7cd5a1630209ed9"><td class="memTemplParams" colspan="2">template&lt;class Response , class Request , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </td></tr>
<tr class="memitem:ae7e8c3b3feb46544e7cd5a1630209ed9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structagrpc_1_1detail_1_1_finish_fn.html#ae7e8c3b3feb46544e7cd5a1630209ed9">operator()</a> (grpc::ServerAsyncReader&lt; Response, Request &gt; &amp;reader, const Response &amp;response, const grpc::Status &amp;status, CompletionToken &amp;&amp;token={}) const noexcept(detail::IS_NOTRHOW_GRPC_INITIATE_COMPLETION_TOKEN&lt; CompletionToken &gt;)</td></tr>
<tr class="memdesc:ae7e8c3b3feb46544e7cd5a1630209ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish a client stream (server-side)  <a href="structagrpc_1_1detail_1_1_finish_fn.html#ae7e8c3b3feb46544e7cd5a1630209ed9">More...</a><br /></td></tr>
<tr class="separator:ae7e8c3b3feb46544e7cd5a1630209ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c07fc0c8854efe921c8344370d50c9d"><td class="memTemplParams" colspan="2">template&lt;class Response , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </td></tr>
<tr class="memitem:a2c07fc0c8854efe921c8344370d50c9d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structagrpc_1_1detail_1_1_finish_fn.html#a2c07fc0c8854efe921c8344370d50c9d">operator()</a> (grpc::ServerAsyncResponseWriter&lt; Response &gt; &amp;writer, const Response &amp;response, const grpc::Status &amp;status, CompletionToken &amp;&amp;token={}) const noexcept(detail::IS_NOTRHOW_GRPC_INITIATE_COMPLETION_TOKEN&lt; CompletionToken &gt;)</td></tr>
<tr class="memdesc:a2c07fc0c8854efe921c8344370d50c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish a unary RPC (server-side)  <a href="structagrpc_1_1detail_1_1_finish_fn.html#a2c07fc0c8854efe921c8344370d50c9d">More...</a><br /></td></tr>
<tr class="separator:a2c07fc0c8854efe921c8344370d50c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaf0a0fe92c4cb58032a14787226281"><td class="memTemplParams" colspan="2">template&lt;class Response , class Request , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </td></tr>
<tr class="memitem:aaaaf0a0fe92c4cb58032a14787226281"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structagrpc_1_1detail_1_1_finish_fn.html#aaaaf0a0fe92c4cb58032a14787226281">operator()</a> (grpc::ServerAsyncReaderWriter&lt; Response, Request &gt; &amp;reader_writer, const grpc::Status &amp;status, CompletionToken &amp;&amp;token={}) const noexcept(detail::IS_NOTRHOW_GRPC_INITIATE_COMPLETION_TOKEN&lt; CompletionToken &gt;)</td></tr>
<tr class="memdesc:aaaaf0a0fe92c4cb58032a14787226281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish a bidirectional stream (server-side)  <a href="structagrpc_1_1detail_1_1_finish_fn.html#aaaaf0a0fe92c4cb58032a14787226281">More...</a><br /></td></tr>
<tr class="separator:aaaaf0a0fe92c4cb58032a14787226281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dd07d4fd1ea5b650ed18d43cfbd46e"><td class="memTemplParams" colspan="2">template&lt;class Response , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </td></tr>
<tr class="memitem:a24dd07d4fd1ea5b650ed18d43cfbd46e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structagrpc_1_1detail_1_1_finish_fn.html#a24dd07d4fd1ea5b650ed18d43cfbd46e">operator()</a> (grpc::ClientAsyncReader&lt; Response &gt; &amp;reader, grpc::Status &amp;status, CompletionToken &amp;&amp;token={}) const noexcept(detail::IS_NOTRHOW_GRPC_INITIATE_COMPLETION_TOKEN&lt; CompletionToken &gt;)</td></tr>
<tr class="memdesc:a24dd07d4fd1ea5b650ed18d43cfbd46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish a server stream (client-side)  <a href="structagrpc_1_1detail_1_1_finish_fn.html#a24dd07d4fd1ea5b650ed18d43cfbd46e">More...</a><br /></td></tr>
<tr class="separator:a24dd07d4fd1ea5b650ed18d43cfbd46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af103e1720dc165be57569675875d5fb4"><td class="memTemplParams" colspan="2">template&lt;class Request , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </td></tr>
<tr class="memitem:af103e1720dc165be57569675875d5fb4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structagrpc_1_1detail_1_1_finish_fn.html#af103e1720dc165be57569675875d5fb4">operator()</a> (grpc::ClientAsyncWriter&lt; Request &gt; &amp;writer, grpc::Status &amp;status, CompletionToken &amp;&amp;token={}) const noexcept(detail::IS_NOTRHOW_GRPC_INITIATE_COMPLETION_TOKEN&lt; CompletionToken &gt;)</td></tr>
<tr class="memdesc:af103e1720dc165be57569675875d5fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish a client stream (client-side)  <a href="structagrpc_1_1detail_1_1_finish_fn.html#af103e1720dc165be57569675875d5fb4">More...</a><br /></td></tr>
<tr class="separator:af103e1720dc165be57569675875d5fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15513693bf3e63a75cfac25d81a102dc"><td class="memTemplParams" colspan="2">template&lt;class Response , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </td></tr>
<tr class="memitem:a15513693bf3e63a75cfac25d81a102dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structagrpc_1_1detail_1_1_finish_fn.html#a15513693bf3e63a75cfac25d81a102dc">operator()</a> (grpc::ClientAsyncResponseReader&lt; Response &gt; &amp;reader, Response &amp;response, grpc::Status &amp;status, CompletionToken &amp;&amp;token={}) const noexcept(detail::IS_NOTRHOW_GRPC_INITIATE_COMPLETION_TOKEN&lt; CompletionToken &gt;)</td></tr>
<tr class="memdesc:a15513693bf3e63a75cfac25d81a102dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish a unary RPC (client-side)  <a href="structagrpc_1_1detail_1_1_finish_fn.html#a15513693bf3e63a75cfac25d81a102dc">More...</a><br /></td></tr>
<tr class="separator:a15513693bf3e63a75cfac25d81a102dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567b2c7bc370d5eb3a39858cd8aff8c1"><td class="memTemplParams" colspan="2">template&lt;class Request , class Response , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </td></tr>
<tr class="memitem:a567b2c7bc370d5eb3a39858cd8aff8c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structagrpc_1_1detail_1_1_finish_fn.html#a567b2c7bc370d5eb3a39858cd8aff8c1">operator()</a> (grpc::ClientAsyncReaderWriter&lt; Request, Response &gt; &amp;reader_writer, grpc::Status &amp;status, CompletionToken &amp;&amp;token={}) const noexcept(detail::IS_NOTRHOW_GRPC_INITIATE_COMPLETION_TOKEN&lt; CompletionToken &gt;)</td></tr>
<tr class="memdesc:a567b2c7bc370d5eb3a39858cd8aff8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish a bidirectional stream (client-side)  <a href="structagrpc_1_1detail_1_1_finish_fn.html#a567b2c7bc370d5eb3a39858cd8aff8c1">More...</a><br /></td></tr>
<tr class="separator:a567b2c7bc370d5eb3a39858cd8aff8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Client and server-side function object to finish RPCs. </p>
<p >The examples below are based on the following .proto file:</p>
<div class="fragment"><div class="line">syntax = &quot;proto3&quot;;</div>
<div class="line"> </div>
<div class="line">package example.v1;</div>
<div class="line"> </div>
<div class="line">service Example {</div>
<div class="line">  rpc ServerStreaming(Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc ClientStreaming(stream Request) returns (Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc BidirectionalStreaming(stream Request) returns (stream Response) {}</div>
<div class="line"> </div>
<div class="line">  rpc Unary(Request) returns (Response) {}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Request {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message Response {</div>
<div class="line">  int32 integer = 1;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>The completion handler created from the completion token that is provided to the functions described below must have an associated executor that refers to a <a class="el" href="classagrpc_1_1_grpc_context.html" title="Execution context based on grpc::CompletionQueue">GrpcContext</a>: <div class="fragment"><div class="line">    asio::io_context io_context;</div>
<div class="line">    asio::co_spawn(</div>
<div class="line">        io_context,</div>
<div class="line">        [&amp;]() -&gt; asio::awaitable&lt;void&gt;</div>
<div class="line">        {</div>
<div class="line">            grpc::ServerContext server_context;</div>
<div class="line">            grpc::ServerAsyncReader&lt;example::v1::Response, example::v1::Request&gt; reader{&amp;server_context};</div>
<div class="line">            <span class="comment">// error: asio::this_coro::executor does not refer to a GrpcContext</span></div>
<div class="line">            <span class="comment">// co_await agrpc::request(&amp;example::v1::Example::AsyncService::RequestClientStreaming, service,</span></div>
<div class="line">            <span class="comment">//                        server_context, reader, asio::use_awaitable);</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment">// correct:</span></div>
<div class="line">            <span class="keyword">co_await</span> <a class="code hl_variable" href="namespaceagrpc.html#a4a11653afb11f9486e4e3db0136a3e08">agrpc::request</a>(&amp;example::v1::Example::AsyncService::RequestClientStreaming, service,</div>
<div class="line">                                    server_context, reader, asio::bind_executor(grpc_context, asio::use_awaitable));</div>
<div class="line">        },</div>
<div class="line">        asio::detached);</div>
<div class="ttc" id="anamespaceagrpc_html_a4a11653afb11f9486e4e3db0136a3e08"><div class="ttname"><a href="namespaceagrpc.html#a4a11653afb11f9486e4e3db0136a3e08">agrpc::request</a></div><div class="ttdeci">constexpr detail::RequestFn request</div><div class="ttdoc">Start a new RPC.</div><div class="ttdef"><b>Definition:</b> rpc.hpp:1493</div></div>
</div><!-- fragment --></dd></dl>
<p><b>Per-Operation Cancellation</b></p>
<p >None. Operations will be cancelled when the deadline of the RPC has been reached (see <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_client_context.html#ad4e16866fee3f6ee5a10efb5be6f4da6">grpc::ClientContext::set_deadline</a>) or the call has been cancelled (see <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_client_context.html#abd0f6715c30287b75288015eee628984">grpc::ClientContext::TryCancel</a> and <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_server_context.html#a88d3a0c3d53e39f38654ce8fba968301">grpc::ServerContext::TryCancel</a>). </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a24dd07d4fd1ea5b650ed18d43cfbd46e" name="a24dd07d4fd1ea5b650ed18d43cfbd46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24dd07d4fd1ea5b650ed18d43cfbd46e">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Response , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::FinishFn::operator() </td>
          <td>(</td>
          <td class="paramtype">grpc::ClientAsyncReader&lt; Response &gt; &amp;&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">grpc::Status &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish a server stream (client-side) </p>
<p >Indicate that the stream is to be finished and request notification for when the call has been ended.</p>
<p >Should not be used concurrently with other operations.</p>
<p >It is appropriate to call this method exactly once when:</p>
<ul>
<li>All messages from the server have been received (either known implictly, or explicitly because a previous read operation returned <code>false</code>).</li>
</ul>
<p>The operation will finish when either:</p>
<ul>
<li>All incoming messages have been read and the server has returned a status. </li>
<li>The server has returned a non-OK status. </li>
<li>The call failed for some reason and the library generated a status.</li>
</ul>
<p>Note that implementations of this method attempt to receive initial metadata from the server if initial metadata has not been received yet.</p>
<p >Side effect:</p>
<ul>
<li>The ClientContext associated with the call is updated with possible initial and trailing metadata received from the server.</li>
</ul>
<p>Example:</p>
<div class="fragment"><div class="line">    grpc::Status status;</div>
<div class="line">    <span class="keywordtype">bool</span> finish_ok = <span class="keyword">co_await</span> <a class="code hl_variable" href="namespaceagrpc.html#a88b9f806c77bb8077f3f7973beede2d0">agrpc::finish</a>(*reader, status, asio::use_awaitable);</div>
<div class="ttc" id="anamespaceagrpc_html_a88b9f806c77bb8077f3f7973beede2d0"><div class="ttname"><a href="namespaceagrpc.html#a88b9f806c77bb8077f3f7973beede2d0">agrpc::finish</a></div><div class="ttdeci">constexpr detail::FinishFn finish</div><div class="ttdoc">Finish a RPC.</div><div class="ttdef"><b>Definition:</b> rpc.hpp:1529</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or the one created by <code><a class="el" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9" title="Create sender completion token.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. The bool should always be <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a567b2c7bc370d5eb3a39858cd8aff8c1" name="a567b2c7bc370d5eb3a39858cd8aff8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567b2c7bc370d5eb3a39858cd8aff8c1">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request , class Response , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::FinishFn::operator() </td>
          <td>(</td>
          <td class="paramtype">grpc::ClientAsyncReaderWriter&lt; Request, Response &gt; &amp;&#160;</td>
          <td class="paramname"><em>reader_writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">grpc::Status &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish a bidirectional stream (client-side) </p>
<p >Indicate that the stream is to be finished and request notification for when the call has been ended.</p>
<p >Should not be used concurrently with other operations.</p>
<p >It is appropriate to call this method exactly once when:</p>
<ul>
<li>All messages from the server have been received (either known implictly, or explicitly because a previous read operation returned <code>false</code>). </li>
<li>The client side has no more message to send (this can be declared implicitly by calling this method, or explicitly through an earlier call to the writes_done method).</li>
</ul>
<p>The operation will finish when either:</p>
<ul>
<li>All incoming messages have been read and the server has returned a status. </li>
<li>The server has returned a non-OK status. </li>
<li>The call failed for some reason and the library generated a status.</li>
</ul>
<p>Note that implementations of this method attempt to receive initial metadata from the server if initial metadata has not been received yet.</p>
<p >Side effect:</p>
<ul>
<li>The ClientContext associated with the call is updated with possible initial and trailing metadata sent from the server.</li>
</ul>
<p>Example:</p>
<div class="fragment"><div class="line">    grpc::Status status;</div>
<div class="line">    <span class="keywordtype">bool</span> finish_ok = <span class="keyword">co_await</span> <a class="code hl_variable" href="namespaceagrpc.html#a88b9f806c77bb8077f3f7973beede2d0">agrpc::finish</a>(*reader_writer, status, asio::use_awaitable);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or the one created by <code><a class="el" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9" title="Create sender completion token.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. The bool should always be <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15513693bf3e63a75cfac25d81a102dc" name="a15513693bf3e63a75cfac25d81a102dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15513693bf3e63a75cfac25d81a102dc">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Response , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::FinishFn::operator() </td>
          <td>(</td>
          <td class="paramtype">grpc::ClientAsyncResponseReader&lt; Response &gt; &amp;&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Response &amp;&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">grpc::Status &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish a unary RPC (client-side) </p>
<p >Receive the server's response message and final status for the call.</p>
<p >This operation will finish when either:</p>
<ul>
<li>The server's response message and status have been received. </li>
<li>The server has returned a non-OK status (no message expected in this case). </li>
<li>The call failed for some reason and the library generated a non-OK status.</li>
</ul>
<p>Side effect:</p>
<ul>
<li>The ClientContext associated with the call is updated with possible initial and trailing metadata sent from the server.</li>
</ul>
<p>Example:</p>
<div class="fragment"><div class="line">    example::v1::Response response;</div>
<div class="line">    grpc::Status status;</div>
<div class="line">    <span class="keywordtype">bool</span> finish_ok = <span class="keyword">co_await</span> <a class="code hl_variable" href="namespaceagrpc.html#a88b9f806c77bb8077f3f7973beede2d0">agrpc::finish</a>(*reader, response, status, asio::use_awaitable);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or the one created by <code><a class="el" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9" title="Create sender completion token.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. The bool should always be <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af103e1720dc165be57569675875d5fb4" name="af103e1720dc165be57569675875d5fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af103e1720dc165be57569675875d5fb4">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Request , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::FinishFn::operator() </td>
          <td>(</td>
          <td class="paramtype">grpc::ClientAsyncWriter&lt; Request &gt; &amp;&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">grpc::Status &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish a client stream (client-side) </p>
<p >Indicate that the stream is to be finished and request notification for when the call has been ended.</p>
<p >Should not be used concurrently with other operations.</p>
<p >It is appropriate to call this method exactly once when:</p>
<ul>
<li>The client side has no more message to send (this can be declared implicitly by calling this method, or explicitly through an earlier call to the writes_done method).</li>
</ul>
<p>The operation will finish when either:</p>
<ul>
<li>All incoming messages have been read and the server has returned a status. </li>
<li>The server has returned a non-OK status. </li>
<li>The call failed for some reason and the library generated a status.</li>
</ul>
<p>Note that implementations of this method attempt to receive initial metadata from the server if initial metadata has not been received yet.</p>
<p >Side effect:</p>
<ul>
<li>The ClientContext associated with the call is updated with possible initial and trailing metadata received from the server. </li>
<li>Attempts to fill in the response parameter that was passed to <code>request</code>.</li>
</ul>
<p>Example:</p>
<div class="fragment"><div class="line">    grpc::Status status;</div>
<div class="line">    <span class="keywordtype">bool</span> finish_ok = <span class="keyword">co_await</span> <a class="code hl_variable" href="namespaceagrpc.html#a88b9f806c77bb8077f3f7973beede2d0">agrpc::finish</a>(*writer, status, asio::use_awaitable);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or the one created by <code><a class="el" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9" title="Create sender completion token.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. The bool should always be <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7e8c3b3feb46544e7cd5a1630209ed9" name="ae7e8c3b3feb46544e7cd5a1630209ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e8c3b3feb46544e7cd5a1630209ed9">&#9670;&nbsp;</a></span>operator()() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Response , class Request , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::FinishFn::operator() </td>
          <td>(</td>
          <td class="paramtype">grpc::ServerAsyncReader&lt; Response, Request &gt; &amp;&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Response &amp;&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const grpc::Status &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish a client stream (server-side) </p>
<p >Side effect:</p>
<ul>
<li>Also sends initial metadata if not alreay sent. </li>
<li>Uses the ServerContext associated with the call to send possible initial and trailing metadata.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Response is not sent if status has a non-OK code.</dd></dl>
<p>gRPC does not take ownership or a reference to response and status, so it is safe to deallocate once finish returns.</p>
<p >Example:</p>
<div class="fragment"><div class="line">    example::v1::Response response;</div>
<div class="line">    <span class="keywordtype">bool</span> finish_ok = <span class="keyword">co_await</span> <a class="code hl_variable" href="namespaceagrpc.html#a88b9f806c77bb8077f3f7973beede2d0">agrpc::finish</a>(reader, response, grpc::Status::OK, asio::use_awaitable);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or the one created by <code><a class="el" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9" title="Create sender completion token.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. <code>true</code> means that the data/metadata/status/etc is going to go to the wire. If it is <code>false</code>, it is not going to the wire because the call is already dead (i.e., canceled, deadline expired, other side dropped the channel, etc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaaaf0a0fe92c4cb58032a14787226281" name="aaaaf0a0fe92c4cb58032a14787226281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaaf0a0fe92c4cb58032a14787226281">&#9670;&nbsp;</a></span>operator()() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Response , class Request , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::FinishFn::operator() </td>
          <td>(</td>
          <td class="paramtype">grpc::ServerAsyncReaderWriter&lt; Response, Request &gt; &amp;&#160;</td>
          <td class="paramname"><em>reader_writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const grpc::Status &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish a bidirectional stream (server-side) </p>
<p >Indicate that the stream is to be finished with a certain status code. Should not be used concurrently with other operations.</p>
<p >It is appropriate to call this method when either:</p>
<ul>
<li>All messages from the client have been received (either known implictly, or explicitly because a previous read operation returned <code>false</code>). </li>
<li>It is desired to end the call early with some non-OK status code.</li>
</ul>
<p>This operation will end when the server has finished sending out initial metadata (if not sent already) and status, or if some failure occurred when trying to do so.</p>
<p >The ServerContext associated with the call is used for sending trailing (and initial if not already sent) metadata to the client. There are no restrictions to the code of status, it may be non-OK. gRPC does not take ownership or a reference to status, so it is safe to to deallocate once finish returns.</p>
<p >Example:</p>
<div class="fragment"><div class="line">    <span class="keywordtype">bool</span> finish_ok = <span class="keyword">co_await</span> <a class="code hl_variable" href="namespaceagrpc.html#a88b9f806c77bb8077f3f7973beede2d0">agrpc::finish</a>(reader_writer, grpc::Status::OK, asio::use_awaitable);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or the one created by <code><a class="el" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9" title="Create sender completion token.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. <code>true</code> means that the data/metadata/status/etc is going to go to the wire. If it is <code>false</code>, it is not going to the wire because the call is already dead (i.e., canceled, deadline expired, other side dropped the channel, etc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c07fc0c8854efe921c8344370d50c9d" name="a2c07fc0c8854efe921c8344370d50c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c07fc0c8854efe921c8344370d50c9d">&#9670;&nbsp;</a></span>operator()() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Response , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::FinishFn::operator() </td>
          <td>(</td>
          <td class="paramtype">grpc::ServerAsyncResponseWriter&lt; Response &gt; &amp;&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Response &amp;&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const grpc::Status &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish a unary RPC (server-side) </p>
<p >Indicate that the RPC is to be finished and request notification when the server has sent the appropriate signals to the client to end the call. Should not be used concurrently with other operations.</p>
<p >Side effect:</p>
<ul>
<li>Also sends initial metadata if not already sent (using the ServerContext associated with the call).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If status has a non-OK code, then response will not be sent, and the client will receive only the status with possible trailing metadata.</dd></dl>
<p>Example:</p>
<div class="fragment"><div class="line">    example::v1::Response response;</div>
<div class="line">    <span class="keywordtype">bool</span> finish_ok = <span class="keyword">co_await</span> <a class="code hl_variable" href="namespaceagrpc.html#a88b9f806c77bb8077f3f7973beede2d0">agrpc::finish</a>(writer, response, grpc::Status::OK, asio::use_awaitable);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or the one created by <code><a class="el" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9" title="Create sender completion token.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. <code>true</code> means that the data/metadata/status/etc is going to go to the wire. If it is <code>false</code>, it is not going to the wire because the call is already dead (i.e., canceled, deadline expired, other side dropped the channel, etc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a613201161863f8ccea494e1c560c56ea" name="a613201161863f8ccea494e1c560c56ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613201161863f8ccea494e1c560c56ea">&#9670;&nbsp;</a></span>operator()() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Response , class CompletionToken  = agrpc::DefaultCompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto agrpc::detail::FinishFn::operator() </td>
          <td>(</td>
          <td class="paramtype">grpc::ServerAsyncWriter&lt; Response &gt; &amp;&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const grpc::Status &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish a server stream (server-side) </p>
<p >Indicate that the stream is to be finished with a certain status code. Should not be used concurrently with other operations.</p>
<p >It is appropriate to call this method when either:</p>
<ul>
<li>All messages from the client have been received (either known implictly, or explicitly because a previous read operation returned <code>false</code>). </li>
<li>It is desired to end the call early with some non-OK status code.</li>
</ul>
<p>This operation will end when the server has finished sending out initial metadata (if not sent already) and status, or if some failure occurred when trying to do so.</p>
<p >The ServerContext associated with the call is used for sending trailing (and initial if not already sent) metadata to the client. There are no restrictions to the code of status, it may be non-OK. gRPC does not take ownership or a reference to status, so it is safe to to deallocate once finish returns.</p>
<p >Example:</p>
<div class="fragment"><div class="line">    <span class="keywordtype">bool</span> finish_ok = <span class="keyword">co_await</span> <a class="code hl_variable" href="namespaceagrpc.html#a88b9f806c77bb8077f3f7973beede2d0">agrpc::finish</a>(writer, grpc::Status::OK, asio::use_awaitable);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A completion token like <code>asio::yield_context</code> or the one created by <code><a class="el" href="namespaceagrpc.html#a35d42ccb3fa5adce6b5c045a275dafa9" title="Create sender completion token.">agrpc::use_sender</a></code>. The completion signature is <code>void(bool)</code>. <code>true</code> means that the data/metadata/status/etc is going to go to the wire. If it is <code>false</code>, it is not going to the wire because the call is already dead (i.e., canceled, deadline expired, other side dropped the channel, etc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceagrpc.html">agrpc</a></li><li class="navelem"><b>detail</b></li><li class="navelem"><a class="el" href="structagrpc_1_1detail_1_1_finish_fn.html">FinishFn</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
